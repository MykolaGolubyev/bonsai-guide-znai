<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" /> 
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"> 
<title>Bonsai: State</title>
<link rel="stylesheet" type="text/css" href="/bonsai-guide-znai/static/css/katex.min.css">
<link rel="stylesheet" type="text/css" href="/bonsai-guide-znai/static/main.css">
<link rel="stylesheet" type="text/css" href="/bonsai-guide-znai/static/css/global-overrides.css">
<link rel="stylesheet" type="text/css" href="/bonsai-guide-znai/style.css">
</head>
<link rel="shortcut icon" href="/bonsai-guide-znai/favicon.png"type="image/ico"/>
<body class="theme-znai-dark">
<script>(function() {
    var themeNameKey = 'znaiTheme';
    var darkThemeName = 'znai-dark';
    var lightThemeName = 'default';

    var znaiTheme = {
        changeHandlers: [],
        addChangeHandler(handler) {
            this.changeHandlers.push(handler);
        },
        removeChangeHandler(handler) {
            var idx = this.changeHandlers.indexOf(handler);
            this.changeHandlers.splice(idx, 1);
        },
        set(name) {
            this.name = name;
            document.body.className = 'theme-' + name;

            var idx = 0;
            var len = this.changeHandlers.length;
            for (; idx < len; idx++) {
                this.changeHandlers[idx](name);
            }
        },
        setExplicitly(name) {
            storeThemeName(name);
            this.set(name);
        },
        setExplicitlyIfNotSetAlready(name) {
            const themeName = getStoredThemeName();
            if (themeName) {
                return
            }

            this.setExplicitly(name)
        },
        toggle() {
            this.setExplicitly(this.name === lightThemeName ? darkThemeName : lightThemeName)
        }
    };

    var mediaThemeName = setLightMatchMediaListenerAndGetThemeName()
    var themeName = getStoredThemeName() || mediaThemeName;
    znaiTheme.set(themeName);

    window.znaiTheme = znaiTheme;

    function getStoredThemeName() {
        return localStorage.getItem(themeNameKey);
    }

    function storeThemeName(name) {
        return localStorage.setItem(themeNameKey, name);
    }

    function setLightMatchMediaListenerAndGetThemeName() {
        if (!window.matchMedia) {
            return darkThemeName;
        }

        var lightQuery = window.matchMedia('(prefers-color-scheme: light)');
        lightQuery.addListener(function (e) {
            const newThemeName = e.matches ? lightThemeName : darkThemeName;
            znaiTheme.setExplicitly(newThemeName);
        });

        return lightQuery.matches ? lightThemeName : darkThemeName;
    }
})()</script>
<div id="znai"><div id="znai-initial-page-loading" style="margin: -20px 0 0 -20px; padding: 0 40px 40px 0; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center">
    <div></div>
</div><section style="max-width: 640px; margin-left: auto; margin-right: auto;">
<article>
<header><h1>Simple State</h1></header>
<p>./02-dynamism.md Chapter 2 briefly touched on the fact that computations capture internal state. This chapter takes a deeper look at the primitives Bonsai provides for introducing and interacting with local state.The simplest kind of state is Bonsai.state . It returns both a value tracking the state's current model, and also a function for updating that model. ocaml skip val state : 'model -&gt; ('model * ('model -&gt; unit Effect.t)) Computation.t 'model : This is the initial value contained in the state, its &quot;default&quot; &quot;model&quot;. Let's break down a simple, yet realistic usage of this computation. ocaml let textbox : (string * Vdom.Node.t) Computation.t = let%sub state, set_state = Bonsai.state &quot;&quot; in let%arr state = state and set_state = set_state in let view = Vdom.Node.input ~attrs: [ Vdom.Attr.value_prop state ; Vdom.Attr.on_input (fun _ new_text -&gt; set_state new_text) ] () in state, view ;; The computation returns the current contents of a textbox, as well as the textbox view itself. The view could be combined with the views from other components, eventually becoming the view for the entire application. The &quot;current value&quot; could be passed on to other components (like we'll do later). In the Bonsai ecosystem, a function that takes any number of Value.t as input and returns a Computation.t is considered a &quot;component&quot;. (In this example, &quot;textbox&quot; takes no Value.t as inputs, but zero is still &quot;any number&quot;, so textbox is a component.) ocaml skip let%sub state, set_state = Bonsai.state &quot;&quot; in This line creates some string state initially containing the empty string. We use let%sub to instantiate this state, giving us access to state and set_state , which have types string Value.t and (string -&gt; unit Effect.t) Value.t , respectively.The let%arr expression maps over two values to produce a computation containing the string and the view. If we attempted to write this code using state and set_state directly instead of through let%arr , the resulting program would not type-check, since both of these variables have Value.t types. let%arr is required in order to get access to the data inside the values.The actual construction of the textbox virtual-dom node is quite boring; we add the value_prop property to keep the textbox contents in sync, and also register an event handler for on_input , an event that fires when the text in the textbox changes. It is not obvious why value_prop is needed. If the contents of the textbox are populated by the user, why re-set them with the current state's value?The answer is complicated, but it boils down to the behavior of the component in weirder circumstances than these basic examples, likeThe set_state function is called by something other than the textbox on_input function. In this scenario, you'd want the contents of the textbox to change alongside the state . The textbox component is removed from the page and then added back again. If value_prop wasn't there, the textbox's default state would be empty! When the event does fire, the set_state function is called with the new string. set_state has type string -&gt; unit Effect.t , which you may recognize from the last section in the ./01-virtual_dom.md virtual-dom chapter. This function is called with the new textbox contents, and the event which is returned schedules the state-setting in the Bonsai event queue.This is the payoff for the unanswered questions in ./01-virtual_dom.md the virtual-dom Chapter:How do I get values of type unit Effect.t that aren't just Ignore and Many : State-transition functions returned by stateful Bonsai components will return unit Effect.t s. Why would I want to use the Bonsai event queue anyway: More complex stateful components (like Bonsai.state_machine ) can witness the changes made to other stateful components, and the Bonsai event-queue guarantees that these updates occur in a consistent order and that downstream components witness changes made to upstream components.</p>
</article>

<article>
<header><h1>Multiple Textboxes</h1></header>
<p>Now that we've built a single textbox component, let's use it in a bigger component: ocaml let two_textboxes : Vdom.Node.t Computation.t = let%sub textbox_a = textbox in let%sub textbox_b = textbox in let%arr contents_a, view_a = textbox_a and contents_b, view_b = textbox_b in let display = Vdom.Node.textf &quot;a: %s, b: %s&quot; contents_a contents_b in Vdom.Node.div ~attrs:[ Vdom.Attr.style (Css_gen.display `Inline_grid) ] [ view_a; view_b; display ] ;; This code is structurally very similar to the textbox component from earlier:It instantiates computations using let%sub (this time with the textbox component itself, rather than the primitive Bonsai.state computation). let%arr is used to build a computation by mapping over values previously bound by let%sub . Of particular note is that the textbox component is instantiated twice (using let%sub ). Because of this, each textbox will have its own independent state.Just for kicks, it's easy to see what would happen if the computation is evaluated once but used twice. In the following code, the only difference between it and the previous example is this line: diff - let%sub textbox_b = textbox in + let textbox_b = textbox_a in ocaml let two_textboxes_shared_state : Vdom.Node.t Computation.t = let%sub textbox_a = textbox in let textbox_b = textbox_a in let%arr contents_a, view_a = textbox_a and contents_b, view_b = textbox_b in let display = Vdom.Node.textf &quot;a: %s, b: %s&quot; contents_a contents_b in Vdom.Node.div ~attrs:[ Vdom.Attr.style (Css_gen.display `Inline_grid) ] [ view_a; view_b; display ] ;; Not very useful, but heartwarming that something sensible happens at all.</p>
</article>

<article>
<header><h1>State Machine</h1></header>
<p>While Bonsai.state is quite useful, sometimes the state contained within an application more closely resembles a state-machine with well-defined transitions between states.Consider a &quot;counter&quot; component that stores (and displays) an integer, alongside buttons which increment and decrement that integer. This component can easily be implemented using Bonsai.state : ocaml let state_based_counter : Vdom.Node.t Computation.t = let%sub state, set_state = Bonsai.state 0 in let%arr state = state and set_state = set_state in let decrement = Vdom.Node.button ~attrs:[ Vdom.Attr.on_click (fun _ -&gt; set_state (state - 1)) ] [ Vdom.Node.text &quot;-1&quot; ] in let increment = Vdom.Node.button ~attrs:[ Vdom.Attr.on_click (fun _ -&gt; set_state (state + 1)) ] [ Vdom.Node.text &quot;+1&quot; ] in Vdom.Node.div [ decrement; Vdom.Node.textf &quot;%d&quot; state; increment ] ;; But there's a tricky bug hidden in this implementation: if a user clicks the button more than once within a span of 16-milliseconds, there's a chance that both button clicks will set the same value! This is because the &quot;current state&quot; value is closed over by the event handler, and this value could be stale because the DOM (including event handlers) is only updated once per frame (approx every 16ms). It's easy to say &quot;clicking on a button that fast isn't particularly likely&quot;, and that may be true, but users are very fast with their keyboards, and using keyboard shortcuts to manipulate applications is common. In addition, if the application has an exceptionally long frame, then the user might accidentally click twice before the frame completes. Fortunately, Bonsai.state_machine0 is here to help! It has this type: ocaml val Bonsai.state_machine0 : (module Action with type t = 'action) -&gt; default_model:'model -&gt; apply_action: (inject:('action -&gt; unit Effect.t) -&gt; schedule_event:(unit Effect.t -&gt; unit) -&gt; 'model -&gt; 'action -&gt; 'model) -&gt; ('model * ('action -&gt; unit Effect.t)) Computation.t Compared to Bonsai.state , there are several similarities:A &quot;Model&quot; first-class-module is passed in, alongside the initial model value ( default_model ). The return value is a Computation.t that provides the current state alongside a function which schedules changes to the state. The main difference is the additional Action module, and apply_action . The apply-action parameter is a function with a fairly long signature, but can be simplified down to the last section: 'model -&gt; 'action -&gt; 'model . This encodes the notion of a state-machine transition: &quot;given the current model and an action, produce a new model.&quot; The inject and schedule_event parameters are rarely used. They are only useful when a state-transition needs to schedule another state transition, either for itself (by composing inject with schedule_event ) or for another state-machine (just calling schedule_event ). So how would we use state_machine0 to fix the bug in the counter application? ocaml module Action = struct type t = | Increment | Decrement [@@deriving sexp_of] end let counter_state_machine : Vdom.Node.t Computation.t = let%sub state, inject = Bonsai.state_machine0 () ~sexp_of_action:[%sexp_of: Action.t] ~default_model:0 ~apply_action:(fun (_ : _ Bonsai.Apply_action_context.t) model action -&gt; match action with | Increment -&gt; model + 1 | Decrement -&gt; model - 1) in let%arr state = state and inject = inject in let decrement = Vdom.Node.button ~attrs:[ Vdom.Attr.on_click (fun _ -&gt; inject Decrement) ] [ Vdom.Node.text &quot;-1&quot; ] in let increment = Vdom.Node.button ~attrs:[ Vdom.Attr.on_click (fun _ -&gt; inject Increment) ] [ Vdom.Node.text &quot;+1&quot; ] in Vdom.Node.div [ decrement; Vdom.Node.textf &quot;%d&quot; state; increment ] ;; First, an Action module is defined as a sum type that lists all the operations that can be performed on the state-machine. This module is passed in to the call to state_machine0 . Then, the apply_action function is defined as a model-transformation function.Using the computation returned by state_machine0 also changes: instead of a &quot;set-state&quot; function, we get a function that &quot;injects&quot; our Action.t into a unit Effect.t .Now, when a button is clicked multiple times in quick succession, instead of calling set_state multiple times with the same value, Bonsai will call inject multiple times, and they'll be processed by apply_action in order, producing the correct result. state_machine0 has a &quot;0&quot; at the end to indicate that it takes &quot;0&quot; additional inputs. Compare the type signatures between state_machine0 and state_machine1 : diff -val state_machine0 +val state_machine1 : (module Action with type t = 'action) -&gt; default_model:'model -&gt; apply_action: (inject:('action -&gt; unit Effect.t) -&gt; schedule_event:(unit Effect.t -&gt; unit) + -&gt; 'input -&gt; 'model -&gt; 'action -&gt; 'model) + -&gt; 'input Value.t -&gt; ('model * ('action -&gt; unit Effect.t)) Computation.t The input is provided to the state-machine in 'input Value.t form, but is available inside the apply_action as a 'input . This allows the state-transition function to depend on the results of other computations.There is no state_machine2 , but implementing one would be trivial, by tupling the input Value.t , and destructuring the inputs inside apply_action .</p>
</article>

<article>
<header><h1>Why should functional programmers be okay with stateful components?</h1></header>
<p>UI programming is inherently stateful. Even a UI element as simple as a textbox needs to keep some state around to store the current contents of the textbox.Many of the tools that functional programmers use for dealing with state almost exclusively involve moving that state out of their programs into a database, or by pulling mutable state out into a small part of the program. These strategies can keep the majority of programs relatively pure and easy to test, but sadly, they don't scale well to UI components for a few reasons:The stateful nature is something that is desirable to test! Bonsai needs to know when the state for a component changes so that it can re-fire calculations of down-stream components. If every component were provided a state-getter and state-setter, this would make component composition more manual work for the programmer; as applications get bigger and bigger, the root element would need to manage potentially dozens or hundreds of states for each transitive sub-component. Adding or removing state from a component would be a breaking change for everyone using it. One way to look at UI components is that they are portals through which an application interacts with the messy world. The job of a component is to translate the unpredictable user actions into a well-understood piece of data.Although the fact that components are stateful might injure your functional programming dogmatism, in fact, it is quite in line with functional programming principles, which aim to isolate effects. The most common way to isolate effects is by having a small kernel of effectful code invoke the pure majority of the logic; in other words, we isolate state by shifting it toward the root of the program. Bonsai offers an alternative tool for isolation. With Bonsai UI components, effectful code gets wrapped up and managed so that the interface provided by the component remains pure; in other words, we isolate state by shifting it toward the leaves of the program.On to ./04-forms.md Chapter 4: Forms.</p>
</article>
</section>
</div>
<script type="text/javascript" src="/bonsai-guide-znai/footer.js"></script>
<script type="text/javascript" src="/bonsai-guide-znai/toc.js"></script>
<script type="text/javascript" src="/bonsai-guide-znai/assets.js"></script>
<script type="text/javascript" src="/bonsai-guide-znai/static/main.js"></script>
<script type="text/javascript" src="/bonsai-guide-znai/search-index.js"></script>
<script>
document.getElementById('znai').innerHTML = '';
/*<!--*/
ReactDOM.render(React.createElement(Documentation, {
  "docMeta" : {
    "viewOn" : {
      "link" : "your-custom-base-url",
      "title" : "View On GitHub"
    },
    "id" : "bonsai-guide-znai",
    "title" : "Bonsai",
    "type" : "Guide",
    "previewEnabled" : false
  },
  "page" : {
    "type" : "Page",
    "content" : [ {
      "type" : "Paragraph",
      "content" : [ {
        "url" : "/bonsai-guide-znai/guide/02-dynamism",
        "isFile" : false,
        "type" : "Link",
        "content" : [ {
          "text" : "Chapter 2",
          "type" : "SimpleText"
        } ]
      }, {
        "text" : " briefly touched on the fact that",
        "type" : "SimpleText"
      }, {
        "type" : "SoftLineBreak"
      }, {
        "text" : "computations capture internal state. This chapter takes a deeper look at",
        "type" : "SimpleText"
      }, {
        "type" : "SoftLineBreak"
      }, {
        "text" : "the primitives Bonsai provides for introducing and interacting with",
        "type" : "SimpleText"
      }, {
        "type" : "SoftLineBreak"
      }, {
        "text" : "local state.",
        "type" : "SimpleText"
      } ]
    }, {
      "id" : "simple-state",
      "title" : "Simple State",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The simplest kind of state is ",
          "type" : "SimpleText"
        }, {
          "code" : "Bonsai.state",
          "type" : "InlinedCode"
        }, {
          "text" : ". It returns both a value",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "tracking the state's current model, and also a function for updating",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "that model.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "ocaml skip val state : 'model -> ('model * ('model -> unit Effect.t)) Computation.t",
          "type" : "InlinedCode"
        } ]
      }, {
        "bulletMarker" : "-",
        "tight" : true,
        "type" : "BulletList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "'model",
              "type" : "InlinedCode"
            }, {
              "text" : ": This is the initial value contained in the state, its",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "\"default\" \"model\".",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Let's break down a simple, yet realistic usage of this computation.",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "let textbox : (string * Vdom.Node.t) Computation.t =\n  let%sub state, set_state = Bonsai.state \"\" in\n  let%arr state = state\n  and set_state = set_state in\n  let view =\n    Vdom.Node.input\n      ~attrs:\n        [ Vdom.Attr.value_prop state\n        ; Vdom.Attr.on_input (fun _ new_text -> set_state new_text)\n        ]\n      ()\n  in\n  state, view\n;;\n",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "src" : "/bonsai-guide-znai/bonsai-build/#textbox",
        "fit" : true,
        "light" : {
          "background" : "#e9edf2",
          "color-scheme" : "light",
          "color" : "#28487c"
        },
        "dark" : {
          "background" : "#101318",
          "color-scheme" : "dark",
          "color" : "#bac9e2"
        },
        "type" : "Iframe"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The computation returns the current contents of a textbox, as well as",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "the textbox view itself. The view could be combined with the views from",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "other components, eventually becoming the view for the entire",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "application. The \"current value\" could be passed on to other components",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "(like we'll do later).",
          "type" : "SimpleText"
        } ]
      }, {
        "attentionType" : "note",
        "content" : [ {
          "type" : "Paragraph",
          "content" : [ {
            "text" : "In the Bonsai ecosystem, a function that takes any number of ",
            "type" : "SimpleText"
          }, {
            "code" : "Value.t",
            "type" : "InlinedCode"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "as input and returns a ",
            "type" : "SimpleText"
          }, {
            "code" : "Computation.t",
            "type" : "InlinedCode"
          }, {
            "text" : " is considered a \"component\". (In",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "this example, \"textbox\" takes no ",
            "type" : "SimpleText"
          }, {
            "code" : "Value.t",
            "type" : "InlinedCode"
          }, {
            "text" : " as inputs, but zero is still",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "\"any number\", so ",
            "type" : "SimpleText"
          }, {
            "code" : "textbox",
            "type" : "InlinedCode"
          }, {
            "text" : " is a component.)",
            "type" : "SimpleText"
          } ]
        } ],
        "type" : "AttentionBlock"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "ocaml skip let%sub state, set_state = Bonsai.state \"\" in",
          "type" : "InlinedCode"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "This line creates some string state initially containing the empty",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "string. We use ",
          "type" : "SimpleText"
        }, {
          "code" : "let%sub",
          "type" : "InlinedCode"
        }, {
          "text" : " to instantiate this state, giving us access to",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "code" : "state",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "set_state",
          "type" : "InlinedCode"
        }, {
          "text" : ", which have types ",
          "type" : "SimpleText"
        }, {
          "code" : "string Value.t",
          "type" : "InlinedCode"
        }, {
          "text" : " and",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "code" : "(string -> unit Effect.t) Value.t",
          "type" : "InlinedCode"
        }, {
          "text" : ", respectively.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The ",
          "type" : "SimpleText"
        }, {
          "code" : "let%arr",
          "type" : "InlinedCode"
        }, {
          "text" : " expression maps over two values to produce a computation",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "containing the string and the view. If we attempted to write this code",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "using ",
          "type" : "SimpleText"
        }, {
          "code" : "state",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "set_state",
          "type" : "InlinedCode"
        }, {
          "text" : " directly instead of through ",
          "type" : "SimpleText"
        }, {
          "code" : "let%arr",
          "type" : "InlinedCode"
        }, {
          "text" : ", the",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "resulting program would not type-check, since both of these variables",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "have ",
          "type" : "SimpleText"
        }, {
          "code" : "Value.t",
          "type" : "InlinedCode"
        }, {
          "text" : " types. ",
          "type" : "SimpleText"
        }, {
          "code" : "let%arr",
          "type" : "InlinedCode"
        }, {
          "text" : " is required in order to get access to",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "the data inside the values.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The actual construction of the textbox virtual-dom node is quite boring;",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "we add the ",
          "type" : "SimpleText"
        }, {
          "code" : "value_prop",
          "type" : "InlinedCode"
        }, {
          "text" : " property to keep the textbox contents in sync,",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "and also register an event handler for ",
          "type" : "SimpleText"
        }, {
          "code" : "on_input",
          "type" : "InlinedCode"
        }, {
          "text" : ", an event that fires",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "when the text in the textbox changes.",
          "type" : "SimpleText"
        } ]
      }, {
        "attentionType" : "note",
        "content" : [ {
          "type" : "Paragraph",
          "content" : [ {
            "text" : "It is not obvious why ",
            "type" : "SimpleText"
          }, {
            "code" : "value_prop",
            "type" : "InlinedCode"
          }, {
            "text" : " is needed. If the contents of the",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "textbox are populated by the user, why re-set them with the current",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "state's value?",
            "type" : "SimpleText"
          } ]
        }, {
          "type" : "Paragraph",
          "content" : [ {
            "text" : "The answer is complicated, but it boils down to the behavior of the",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "component in weirder circumstances than these basic examples, like",
            "type" : "SimpleText"
          } ]
        }, {
          "delimiter" : ".",
          "startNumber" : 1,
          "type" : "OrderedList",
          "content" : [ {
            "type" : "ListItem",
            "content" : [ {
              "type" : "Paragraph",
              "content" : [ {
                "text" : "The ",
                "type" : "SimpleText"
              }, {
                "code" : "set_state",
                "type" : "InlinedCode"
              }, {
                "text" : " function is called by something ",
                "type" : "SimpleText"
              }, {
                "type" : "Emphasis",
                "content" : [ {
                  "text" : "other",
                  "type" : "SimpleText"
                } ]
              }, {
                "text" : " than the",
                "type" : "SimpleText"
              }, {
                "type" : "SoftLineBreak"
              }, {
                "text" : "textbox ",
                "type" : "SimpleText"
              }, {
                "code" : "on_input",
                "type" : "InlinedCode"
              }, {
                "text" : " function. In this scenario, you'd want the",
                "type" : "SimpleText"
              }, {
                "type" : "SoftLineBreak"
              }, {
                "text" : "contents of the textbox to change alongside the ",
                "type" : "SimpleText"
              }, {
                "code" : "state",
                "type" : "InlinedCode"
              }, {
                "text" : ".",
                "type" : "SimpleText"
              } ]
            } ]
          }, {
            "type" : "ListItem",
            "content" : [ {
              "type" : "Paragraph",
              "content" : [ {
                "text" : "The textbox component is removed from the page and then added back",
                "type" : "SimpleText"
              }, {
                "type" : "SoftLineBreak"
              }, {
                "text" : "again. If ",
                "type" : "SimpleText"
              }, {
                "code" : "value_prop",
                "type" : "InlinedCode"
              }, {
                "text" : " wasn't there, the textbox's default state",
                "type" : "SimpleText"
              }, {
                "type" : "SoftLineBreak"
              }, {
                "text" : "would be empty!",
                "type" : "SimpleText"
              } ]
            } ]
          } ]
        } ],
        "type" : "AttentionBlock"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "When the event does fire, the ",
          "type" : "SimpleText"
        }, {
          "code" : "set_state",
          "type" : "InlinedCode"
        }, {
          "text" : " function is called with the",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "new string. ",
          "type" : "SimpleText"
        }, {
          "code" : "set_state",
          "type" : "InlinedCode"
        }, {
          "text" : " has type ",
          "type" : "SimpleText"
        }, {
          "code" : "string -> unit Effect.t",
          "type" : "InlinedCode"
        }, {
          "text" : ", which you",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "may recognize from the last section in the",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "url" : "/bonsai-guide-znai/guide/01-virtual_dom",
          "isFile" : false,
          "type" : "Link",
          "content" : [ {
            "text" : "virtual-dom",
            "type" : "SimpleText"
          } ]
        }, {
          "text" : " chapter. This function is called with",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "the new textbox contents, and the event which is returned schedules the",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "state-setting in the Bonsai event queue.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "This is the payoff for the unanswered questions in ",
          "type" : "SimpleText"
        }, {
          "url" : "/bonsai-guide-znai/guide/01-virtual_dom",
          "isFile" : false,
          "type" : "Link",
          "content" : [ {
            "text" : "the virtual-dom",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "Chapter",
            "type" : "SimpleText"
          } ]
        }, {
          "text" : ":",
          "type" : "SimpleText"
        } ]
      }, {
        "delimiter" : ".",
        "startNumber" : 1,
        "type" : "OrderedList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "type" : "Emphasis",
              "content" : [ {
                "text" : "How do I get values of type ",
                "type" : "SimpleText"
              }, {
                "code" : "unit Effect.t",
                "type" : "InlinedCode"
              }, {
                "text" : " that aren't just",
                "type" : "SimpleText"
              }, {
                "type" : "SoftLineBreak"
              }, {
                "code" : "Ignore",
                "type" : "InlinedCode"
              }, {
                "text" : " and ",
                "type" : "SimpleText"
              }, {
                "code" : "Many",
                "type" : "InlinedCode"
              } ]
            }, {
              "text" : ": State-transition functions returned by",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "stateful Bonsai components will return ",
              "type" : "SimpleText"
            }, {
              "code" : "unit Effect.t",
              "type" : "InlinedCode"
            }, {
              "text" : "s.",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "type" : "Emphasis",
              "content" : [ {
                "text" : "Why would I want to use the Bonsai event queue anyway",
                "type" : "SimpleText"
              } ]
            }, {
              "text" : ": More",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "complex stateful components (like ",
              "type" : "SimpleText"
            }, {
              "code" : "Bonsai.state_machine",
              "type" : "InlinedCode"
            }, {
              "text" : ") can",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "witness the changes made to other stateful components, and the",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "Bonsai event-queue guarantees that these updates occur in a",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "consistent order and that downstream components witness changes made",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "to upstream components.",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      } ]
    }, {
      "id" : "multiple-textboxes",
      "title" : "Multiple Textboxes",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Now that we've built a single textbox component, let's use it in a",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "bigger component:",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "let two_textboxes : Vdom.Node.t Computation.t =\n  let%sub textbox_a = textbox in\n  let%sub textbox_b = textbox in\n  let%arr contents_a, view_a = textbox_a\n  and contents_b, view_b = textbox_b in\n  let display = Vdom.Node.textf \"a: %s, b: %s\" contents_a contents_b in\n  Vdom.Node.div\n    ~attrs:[ Vdom.Attr.style (Css_gen.display `Inline_grid) ]\n    [ view_a; view_b; display ]\n;;\n",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "src" : "/bonsai-guide-znai/bonsai-build/#two_textboxes",
        "fit" : true,
        "light" : {
          "background" : "#e9edf2",
          "color-scheme" : "light",
          "color" : "#28487c"
        },
        "dark" : {
          "background" : "#101318",
          "color-scheme" : "dark",
          "color" : "#bac9e2"
        },
        "type" : "Iframe"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "This code is structurally very similar to the textbox component from",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "earlier:",
          "type" : "SimpleText"
        } ]
      }, {
        "delimiter" : ".",
        "startNumber" : 1,
        "type" : "OrderedList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "It instantiates computations using ",
              "type" : "SimpleText"
            }, {
              "code" : "let%sub",
              "type" : "InlinedCode"
            }, {
              "text" : " (this time with the",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "code" : "textbox",
              "type" : "InlinedCode"
            }, {
              "text" : " component itself, rather than the primitive ",
              "type" : "SimpleText"
            }, {
              "code" : "Bonsai.state",
              "type" : "InlinedCode"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "computation).",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "code" : "let%arr",
              "type" : "InlinedCode"
            }, {
              "text" : " is used to build a computation by mapping over values",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "previously bound by ",
              "type" : "SimpleText"
            }, {
              "code" : "let%sub",
              "type" : "InlinedCode"
            }, {
              "text" : ".",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Of particular note is that the ",
          "type" : "SimpleText"
        }, {
          "code" : "textbox",
          "type" : "InlinedCode"
        }, {
          "text" : " component is instantiated twice",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "(using ",
          "type" : "SimpleText"
        }, {
          "code" : "let%sub",
          "type" : "InlinedCode"
        }, {
          "text" : "). Because of this, each textbox will have its own",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "independent state.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Just for kicks, it's easy to see what would happen if the computation is",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "evaluated once but used twice. In the following code, the only",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "difference between it and the previous example is this line:",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "diff",
        "snippet" : "- let%sub textbox_b = textbox in\n+ let textbox_b = textbox_a in\n",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "lang" : "ocaml",
        "snippet" : "let two_textboxes_shared_state : Vdom.Node.t Computation.t =\n  let%sub textbox_a = textbox in\n  let textbox_b = textbox_a in\n  let%arr contents_a, view_a = textbox_a\n  and contents_b, view_b = textbox_b in\n  let display = Vdom.Node.textf \"a: %s, b: %s\" contents_a contents_b in\n  Vdom.Node.div\n    ~attrs:[ Vdom.Attr.style (Css_gen.display `Inline_grid) ]\n    [ view_a; view_b; display ]\n;;\n",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "src" : "/bonsai-guide-znai/bonsai-build/#two_textboxes_shared_state",
        "fit" : true,
        "light" : {
          "background" : "#e9edf2",
          "color-scheme" : "light",
          "color" : "#28487c"
        },
        "dark" : {
          "background" : "#101318",
          "color-scheme" : "dark",
          "color" : "#bac9e2"
        },
        "type" : "Iframe"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Not very useful, but heartwarming that something sensible happens at",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "all.",
          "type" : "SimpleText"
        } ]
      } ]
    }, {
      "id" : "state-machine",
      "title" : "State Machine",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "While ",
          "type" : "SimpleText"
        }, {
          "code" : "Bonsai.state",
          "type" : "InlinedCode"
        }, {
          "text" : " is quite useful, sometimes the state contained",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "within an application more closely resembles a state-machine with",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "well-defined transitions between states.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Consider a \"counter\" component that stores (and displays) an integer,",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "alongside buttons which increment and decrement that integer. This",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "component can easily be implemented using ",
          "type" : "SimpleText"
        }, {
          "code" : "Bonsai.state",
          "type" : "InlinedCode"
        }, {
          "text" : ":",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "let state_based_counter : Vdom.Node.t Computation.t =\n  let%sub state, set_state = Bonsai.state 0 in\n  let%arr state = state\n  and set_state = set_state in\n  let decrement =\n    Vdom.Node.button\n      ~attrs:[ Vdom.Attr.on_click (fun _ -> set_state (state - 1)) ]\n      [ Vdom.Node.text \"-1\" ]\n  in\n  let increment =\n    Vdom.Node.button\n      ~attrs:[ Vdom.Attr.on_click (fun _ -> set_state (state + 1)) ]\n      [ Vdom.Node.text \"+1\" ]\n  in\n  Vdom.Node.div [ decrement; Vdom.Node.textf \"%d\" state; increment ]\n;;\n",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "src" : "/bonsai-guide-znai/bonsai-build/#state_based_counter",
        "fit" : true,
        "light" : {
          "background" : "#e9edf2",
          "color-scheme" : "light",
          "color" : "#28487c"
        },
        "dark" : {
          "background" : "#101318",
          "color-scheme" : "dark",
          "color" : "#bac9e2"
        },
        "type" : "Iframe"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "But there's a tricky bug hidden in this implementation: if a user clicks",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "the button more than once within a span of 16-milliseconds, there's a",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "chance that both button clicks will set the same value! This is because",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "the \"current state\" value is closed over by the event handler, and this",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "value could be stale because the DOM (including event handlers) is only",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "updated once per frame (approx every 16ms).",
          "type" : "SimpleText"
        } ]
      }, {
        "attentionType" : "note",
        "content" : [ {
          "type" : "Paragraph",
          "content" : [ {
            "text" : "It's easy to say \"clicking on a button that fast isn't particularly",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "likely\", and that may be true, but users are ",
            "type" : "SimpleText"
          }, {
            "type" : "Emphasis",
            "content" : [ {
              "text" : "very fast",
              "type" : "SimpleText"
            } ]
          }, {
            "text" : " with their",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "keyboards, and using keyboard shortcuts to manipulate applications is",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "common. In addition, if the application has an exceptionally long frame,",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "then the user might accidentally click twice before the frame completes.",
            "type" : "SimpleText"
          } ]
        } ],
        "type" : "AttentionBlock"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Fortunately, ",
          "type" : "SimpleText"
        }, {
          "code" : "Bonsai.state_machine0",
          "type" : "InlinedCode"
        }, {
          "text" : " is here to help! It has this type:",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "val Bonsai.state_machine0\n  :  (module Action with type t = 'action)\n  -> default_model:'model\n  -> apply_action:\n       (inject:('action -> unit Effect.t)\n        -> schedule_event:(unit Effect.t -> unit)\n        -> 'model\n        -> 'action\n        -> 'model)\n  -> ('model * ('action -> unit Effect.t)) Computation.t\n",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Compared to ",
          "type" : "SimpleText"
        }, {
          "code" : "Bonsai.state",
          "type" : "InlinedCode"
        }, {
          "text" : ", there are several similarities:",
          "type" : "SimpleText"
        } ]
      }, {
        "delimiter" : ".",
        "startNumber" : 1,
        "type" : "OrderedList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "A \"Model\" first-class-module is passed in, alongside the initial",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "model value (",
              "type" : "SimpleText"
            }, {
              "code" : "default_model",
              "type" : "InlinedCode"
            }, {
              "text" : ").",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "The return value is a ",
              "type" : "SimpleText"
            }, {
              "code" : "Computation.t",
              "type" : "InlinedCode"
            }, {
              "text" : " that provides the current",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "state alongside a function which schedules changes to the state.",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "The main difference is the additional ",
          "type" : "SimpleText"
        }, {
          "code" : "Action",
          "type" : "InlinedCode"
        }, {
          "text" : " module, and",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "code" : "apply_action",
          "type" : "InlinedCode"
        }, {
          "text" : ". The apply-action parameter is a function with a fairly",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "long signature, but can be simplified down to the last section:",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "code" : "'model -> 'action -> 'model",
          "type" : "InlinedCode"
        }, {
          "text" : ". This encodes the notion of a",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "state-machine transition: \"given the current model and an action,",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "produce a new model.\"",
          "type" : "SimpleText"
        } ]
      }, {
        "attentionType" : "note",
        "content" : [ {
          "type" : "Paragraph",
          "content" : [ {
            "text" : "The ",
            "type" : "SimpleText"
          }, {
            "code" : "inject",
            "type" : "InlinedCode"
          }, {
            "text" : " and ",
            "type" : "SimpleText"
          }, {
            "code" : "schedule_event",
            "type" : "InlinedCode"
          }, {
            "text" : " parameters are rarely used. They are",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "only useful when a state-transition needs to schedule ",
            "type" : "SimpleText"
          }, {
            "type" : "Emphasis",
            "content" : [ {
              "text" : "another",
              "type" : "SimpleText"
            } ]
          }, {
            "text" : " state",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "transition, either for itself (by composing ",
            "type" : "SimpleText"
          }, {
            "code" : "inject",
            "type" : "InlinedCode"
          }, {
            "text" : " with",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "code" : "schedule_event",
            "type" : "InlinedCode"
          }, {
            "text" : ") or for another state-machine (just calling",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "code" : "schedule_event",
            "type" : "InlinedCode"
          }, {
            "text" : ").",
            "type" : "SimpleText"
          } ]
        } ],
        "type" : "AttentionBlock"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "So how would we use ",
          "type" : "SimpleText"
        }, {
          "code" : "state_machine0",
          "type" : "InlinedCode"
        }, {
          "text" : " to fix the bug in the counter",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "application?",
          "type" : "SimpleText"
        } ]
      }, {
        "lang" : "ocaml",
        "snippet" : "module Action = struct\n  type t =\n    | Increment\n    | Decrement\n  [@@deriving sexp_of]\nend\n\nlet counter_state_machine : Vdom.Node.t Computation.t =\n  let%sub state, inject =\n    Bonsai.state_machine0\n      ()\n      ~sexp_of_action:[%sexp_of: Action.t]\n      ~default_model:0\n      ~apply_action:(fun (_ : _ Bonsai.Apply_action_context.t) model action ->\n        match action with\n        | Increment -> model + 1\n        | Decrement -> model - 1)\n  in\n  let%arr state = state\n  and inject = inject in\n  let decrement =\n    Vdom.Node.button\n      ~attrs:[ Vdom.Attr.on_click (fun _ -> inject Decrement) ]\n      [ Vdom.Node.text \"-1\" ]\n  in\n  let increment =\n    Vdom.Node.button\n      ~attrs:[ Vdom.Attr.on_click (fun _ -> inject Increment) ]\n      [ Vdom.Node.text \"+1\" ]\n  in\n  Vdom.Node.div [ decrement; Vdom.Node.textf \"%d\" state; increment ]\n;;\n",
        "lineNumber" : "",
        "type" : "Snippet"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "First, an ",
          "type" : "SimpleText"
        }, {
          "code" : "Action",
          "type" : "InlinedCode"
        }, {
          "text" : " module is defined as a sum type that lists all the",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "operations that can be performed on the state-machine. This module is",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "passed in to the call to ",
          "type" : "SimpleText"
        }, {
          "code" : "state_machine0",
          "type" : "InlinedCode"
        }, {
          "text" : ". Then, the ",
          "type" : "SimpleText"
        }, {
          "code" : "apply_action",
          "type" : "InlinedCode"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "function is defined as a model-transformation function.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Using the computation returned by ",
          "type" : "SimpleText"
        }, {
          "code" : "state_machine0",
          "type" : "InlinedCode"
        }, {
          "text" : " also changes: instead",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "of a \"set-state\" function, we get a function that \"injects\" our",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "code" : "Action.t",
          "type" : "InlinedCode"
        }, {
          "text" : " into a ",
          "type" : "SimpleText"
        }, {
          "code" : "unit Effect.t",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Now, when a button is clicked multiple times in quick succession,",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "instead of calling ",
          "type" : "SimpleText"
        }, {
          "code" : "set_state",
          "type" : "InlinedCode"
        }, {
          "text" : " multiple times with the same value,",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "Bonsai will call ",
          "type" : "SimpleText"
        }, {
          "code" : "inject",
          "type" : "InlinedCode"
        }, {
          "text" : " multiple times, and they'll be processed by",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "code" : "apply_action",
          "type" : "InlinedCode"
        }, {
          "text" : " in order, producing the correct result.",
          "type" : "SimpleText"
        } ]
      }, {
        "attentionType" : "note",
        "content" : [ {
          "type" : "Paragraph",
          "content" : [ {
            "code" : "state_machine0",
            "type" : "InlinedCode"
          }, {
            "text" : " has a \"0\" at the end to indicate that it takes \"0\"",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "additional inputs. Compare the type signatures between ",
            "type" : "SimpleText"
          }, {
            "code" : "state_machine0",
            "type" : "InlinedCode"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "and ",
            "type" : "SimpleText"
          }, {
            "code" : "state_machine1",
            "type" : "InlinedCode"
          }, {
            "text" : ":",
            "type" : "SimpleText"
          } ]
        }, {
          "lang" : "diff",
          "snippet" : "-val state_machine0\n+val state_machine1\n   :  (module Action with type t = 'action)\n   -> default_model:'model\n   -> apply_action:\n        (inject:('action -> unit Effect.t)\n         -> schedule_event:(unit Effect.t -> unit)\n+        -> 'input\n         -> 'model\n         -> 'action\n         -> 'model)\n+  -> 'input Value.t\n   -> ('model * ('action -> unit Effect.t)) Computation.t\n",
          "lineNumber" : "",
          "type" : "Snippet"
        }, {
          "type" : "Paragraph",
          "content" : [ {
            "text" : "The input is provided to the state-machine in ",
            "type" : "SimpleText"
          }, {
            "code" : "'input Value.t",
            "type" : "InlinedCode"
          }, {
            "text" : " form, but",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "is available inside the ",
            "type" : "SimpleText"
          }, {
            "code" : "apply_action",
            "type" : "InlinedCode"
          }, {
            "text" : " as a ",
            "type" : "SimpleText"
          }, {
            "code" : "'input",
            "type" : "InlinedCode"
          }, {
            "text" : ". This allows the",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "state-transition function to depend on the results of other",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "computations.",
            "type" : "SimpleText"
          } ]
        }, {
          "type" : "Paragraph",
          "content" : [ {
            "text" : "There is no ",
            "type" : "SimpleText"
          }, {
            "code" : "state_machine2",
            "type" : "InlinedCode"
          }, {
            "text" : ", but implementing one would be trivial, by",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "text" : "tupling the input ",
            "type" : "SimpleText"
          }, {
            "code" : "Value.t",
            "type" : "InlinedCode"
          }, {
            "text" : ", and destructuring the inputs inside",
            "type" : "SimpleText"
          }, {
            "type" : "SoftLineBreak"
          }, {
            "code" : "apply_action",
            "type" : "InlinedCode"
          }, {
            "text" : ".",
            "type" : "SimpleText"
          } ]
        } ],
        "type" : "AttentionBlock"
      } ]
    }, {
      "id" : "why-should-functional-programmers-be-okay-with-stateful-components",
      "title" : "Why should functional programmers be okay with stateful components?",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "UI programming is inherently stateful. Even a UI element as simple as a",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "textbox needs to keep some state around to store the current contents of",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "the textbox.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Many of the tools that functional programmers use for dealing with state",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "almost exclusively involve moving that state out of their programs into",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "a database, or by pulling mutable state out into a small part of the",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "program. These strategies can keep the majority of programs relatively",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "pure and easy to test, but sadly, they don't scale well to UI components",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "for a few reasons:",
          "type" : "SimpleText"
        } ]
      }, {
        "delimiter" : ".",
        "startNumber" : 1,
        "type" : "OrderedList",
        "content" : [ {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "The stateful nature is something that is desirable to test!",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "Bonsai needs to know when the state for a component changes so that",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "it can re-fire calculations of down-stream components.",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "If every component were provided a state-getter and state-setter,",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "this would make component composition more manual work for the",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "programmer; as applications get bigger and bigger, the root element",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "would need to manage potentially dozens or hundreds of states for",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "each transitive sub-component.",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "type" : "ListItem",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "Adding or removing state from a component would be a breaking change",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "for everyone using it.",
              "type" : "SimpleText"
            } ]
          } ]
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "One way to look at UI components is that they are portals through which",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "an application interacts with the messy world. The job of a component is",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "to translate the unpredictable user actions into a well-understood piece",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "of data.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Although the fact that components are stateful might injure your",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "functional programming dogmatism, in fact, it is quite in line with",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "functional programming principles, which aim to isolate effects. The",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "most common way to isolate effects is by having a small kernel of",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "effectful code invoke the pure majority of the logic; in other words, we",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "isolate state by shifting it toward the root of the program. Bonsai",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "offers an alternative tool for isolation. With Bonsai UI components,",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "effectful code gets wrapped up and managed so that the interface",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "provided by the component remains pure; in other words, we isolate state",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "by shifting it toward the leaves of the program.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "On to ",
          "type" : "SimpleText"
        }, {
          "url" : "/bonsai-guide-znai/guide/04-forms",
          "isFile" : false,
          "type" : "Link",
          "content" : [ {
            "text" : "Chapter 4: Forms",
            "type" : "SimpleText"
          } ]
        }, {
          "text" : ".",
          "type" : "SimpleText"
        } ]
      } ]
    } ],
    "lastModifiedTime" : 1695814630488,
    "tocItem" : {
      "chapterTitle" : "Guide",
      "pageTitle" : "State",
      "pageMeta" : {
        "title" : [ "State" ]
      },
      "dirName" : "guide",
      "fileName" : "03-state",
      "viewOnRelativePath" : null,
      "pageSectionIdTitles" : [ {
        "title" : "Simple State",
        "id" : "simple-state"
      }, {
        "title" : "Multiple Textboxes",
        "id" : "multiple-textboxes"
      }, {
        "title" : "State Machine",
        "id" : "state-machine"
      }, {
        "title" : "Why should functional programmers be okay with stateful components?",
        "id" : "why-should-functional-programmers-be-okay-with-stateful-components"
      } ]
    }
  }
}), document.getElementById("znai"));
/*-->*/

</script>

</body>
</html>
