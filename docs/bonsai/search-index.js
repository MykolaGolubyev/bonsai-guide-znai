znaiSearchData = [["guide@@00-introduction@@web-apps-at-10000-feet","Guide","Introduction","Web Apps at 10,000 Feet","This guide will teach you how to build user interfaces in the browser using several libraries, primarily Bonsai and Virtual_dom . Together, these libraries allow you to build applications in a functional style instead of the imperative style encouraged by the browser's API.In this guide we aim to explain how to use Bonsai, and, to a lesser degree, how Bonsai works under the hood. We hope that the latter will equip you with the knowledge necessary to tune the performance of your applications.The browser understands three languages: Javascript, HTML, CSS. Jane Street programmers only understand one language: OCaml. Thus, we've made it possible to write all three of the browser languages using OCaml. js_of_ocaml is an OCaml-to-Javascript compiler. virtual_dom is a library for building values that represent a chunk of HTML. css_gen is a library for writing CSS styles in a type safe manner. The CSS situation is a little more nuanced, since we actually recommend writing CSS directly using ppx_css .A user interface is a function from data to view. In types: ocaml (* Virtual_dom.Vdom.Node.t represents your application's view *) open Virtual_dom val ui : Your_input_type_here.t -> Vdom.Node.t It's easy to write composable views with such functions, since all you need to return is a plain old OCaml value. A small amount of boilerplate can turn this function into a simple web app that continuously displays the result of the function.Of course, this is a huge simplification; in a real app, you usually want:Interactivity, so the user can click on, type into, and navigate through things. Incrementality, so that large amounts of highly dynamically data can be displayed without the interface lagging. Bonsai provides these features while still encouraging the composition and abstraction properties of regular OCaml code. Bonsai wants you to forget it is there. The signature of a Bonsai app looks a bit like this: ocaml open Bonsai_web val ui : Your_input_type_here.t Value.t -> Vdom.Node.t Computation.t It's just like before, except the input is wrapped with Value.t and the output is wrapped with Computation.t . While there is slightly more friction, writing re-usable UI components is just as easy. In addition, we've expanded the kinds of components you can write, since Computation.t encapsulates incremental state machines, which is how interactivity is added to an interface.Both these types are covered in detail in chapters ./02-dynamism.md 2 and ./03-state.md 3."],["guide@@00-introduction@@the-underlying-machinery","Guide","Introduction","The Underlying Machinery","The incrementality in Bonsai comes from the Incremental library. When a web page loads, Bonsai compiles the top-level Vdom.Node.t Computation.t into something akin to Vdom.Node.t Incr.t . Then the Incr_dom library handles running the main loop to keep the incremental graph stabilized (i.e. up-to-date).The Vdom.Node.t representing the current view gets put onto the screen via a diff-and-patch process. The virtual_dom library always keeps track of the previous Vdom.Node.t that it told the browser to display. Whenever we request a new Vdom.Node.t to be displayed on the screen, the library first compares it to the previous view to see what changed, and then it applies just those changes to what the browser is displaying.Details regarding Incremental, and the virtual-dom diff-and-patch strategy are abstracted away so you'll rarely need to think about them. However, a good cost model will help you to avoid or debug performance pitfalls. Throughout the rest of this guide, we will endeavor to provide such a cost model."],["guide@@01-virtual_dom@@vdom-node-t","Guide","Virtual-dom","Vdom.Node.t","Browser interfaces are described by a tree of HTML elements, each of which can have some attributes attached. The virtual_dom library provides an OCaml interface for constructing these trees.This wouldn't be a programming tutorial without a hello world example, which introduces the Vdom.Node.text node constructor. ocaml let hello_world : Vdom.Node.t = Vdom.Node.text \"hello world!\" The text node will frequently be the \"leaf\" of a view (there are no \"children\" of a text node). Let's put some text inside a bulleted list by using some more node constructors: ocaml let bulleted_list : Vdom.Node.t = let open Vdom.Node in div [ h3 [ text \"Norwegian Pancakes\" ] ; ul [ li [ text \"3 eggs\" ] ; li [ text \"2 cups of milk\" ] ; li [ text \"1 cup of flour\" ] ] ] ;; For the bulleted list, the ul and li functions are required. These correspond to the https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul ul element and the https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li li element, which MDN helpfully tells us stands for Unordered List and List Item h3 is short for \"header level 3\", and is responsible for the larger font in the title text, and div is a https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div \"content division\" and serves as a useful wrapper for the rest of the content. There is a Vdom.Node.* node constructor function for almost every https://developer.mozilla.org/en-US/docs/Web/HTML/Element dom node. If a constructor is missing, Vdom.Node.create is available to manually specify the tag, but the Virtual_dom maintainers gladly accept contributions back to the main library!"],["guide@@01-virtual_dom@@vdom-attr-t","Guide","Virtual-dom","Vdom.Attr.t","An optional argument to the Vdom.Node.* constructor functions is a Vdom.Attr.t list . These Attr.t correspond to https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes DOM attributes, https://developer.mozilla.org/en-US/docs/Web/API/Element#properties DOM properties, and https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Event_handlers DOM event_handlers.Attributes can be used to tweak the appearance and behavior of the nodes that they are attached to, for instance, by adding placeholder text to a textbox: ocaml let input_placeholder : Vdom.Node.t = Vdom.Node.input ~attrs:[ Vdom.Attr.placeholder \"placeholder text here\" ] () ;; Or coloring text with inline css: ocaml let css_gen : Vdom.Node.t = Vdom.Node.span ~attrs:[ Vdom.Attr.style (Css_gen.color (`Name \"red\")) ] [ Vdom.Node.text \"this text is red\" ] ;; ./08-css.md The 8th chapter \"css\" goes into much more depth on the styling attributes.Finally, there are \"event handler\" attributes which register functions that are called when a user interacts with the element (like clicking on buttons or typing into a text box). ocaml let clicky : Vdom.Node.t = Vdom.Node.button ~attrs: [ Vdom.Attr.on_click (fun (_evt : mouse_event) -> alert \"hello there!\"; Ui_effect.Ignore) ] [ Vdom.Node.text \"click me!\" ] ;; These functions usually receive a browser-level event value (ignored in the above example as _evt ) alongside any useful data extracted from that event. For example, see the following event-handler attributes for mouse-clicks and typing into a textbox: ocaml val Vdom.Attr.on_click : (mouse_event -> unit Vdom.Effect.t) -> Vdom.Attr.t val Vdom.Attr.on_input : (input_event -> string -> unit Vdom.Effect.t) -> Vdom.Attr.t You'll notice that because on_input is used to respond to users typing into a textbox, the handler function is also given a string that holds the current contents of that textbox.The browser-level event-values like mouse_event and input_event are almost always ignored in Bonsai apps.The return type for these event handler functions is unit Vdom.Effect.t , which is the final type that we care about in the Virtual_dom library."],["guide@@01-virtual_dom@@unit-vdom-effect-t","Guide","Virtual-dom","unit Vdom.Effect.t","In the example above, the on_click handler function returned Vdom.Effect.Ignore . However, the alert definitely fires when you click on it, so what is this value doing, and why must these event-handlers return values of type unit Vdom.Effect.t in the first place?In reality, values of type unit Vdom.Effect.t are used to schedule work on Bonsai's event-queue. Vdom.Effect.Ignore is the no-op event, and it schedules no work on the event-queue. Vdom.Effect.Many [a; b; c] wraps up multiple events, scheduling them all in order.That leaves us with two more question:How do I get values of type unit Vdom.Effect.t that aren't just Ignore and Many Why would I want to use the Bonsai event queue anyway? Both of which will be answered in ./03-state.md Bonsai Guide Part 3: State. unit Vdom.Effect.t is actually an alias for unit Ui_effect.t . They are the same type, and it's merely re-exported from the Vdom library as a convenience. If you see a unit Ui_effect.t (either in another library, or from merlin), know that it is the same thing as unit Vdom.Effect.t ."],["guide@@01-virtual_dom@@the-underlying-machinery","Guide","Virtual-dom","The Underlying Machinery","A virtual-DOM is an immutable tree of immutable UI elements that represents the view of the application at a point in time. This is in contrast to https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model the DOM (Document Object Model), which is a mutable tree of mutable UI elements. The term \"virtual-DOM\" is not unique to Bonsai. Many other UI libraries like https://reactjs.org/docs/faq-internals.html React, https://github.com/elm/virtual-DOM Elm, and https://vuejs.org/v2/guide/render-function.html#The-Virtual-DOM Vue have their own \"virtual-DOM\" libraries that all share similar goals. With the (not-virtual) DOM, the program mutates the tree of UI components in order to update the view, but with the virtual-DOM, the program produces a new tree every time the view changes. While this may appear to be a performance nightmare, many of the tools that we use to reduce duplication of work in regular programs also work well to prevent re-computing parts of this sub-view.The Virtual_dom library also contains functions that diff two versions of a virtual-dom tree. The diff can be used as instructions for mutating the DOM to reflect the contents of the \"next\" virtual-DOM node. These functions are quite fundamental, but Bonsai handles the calls to these functions, so application developers are solely concerned with producing new vdom trees.Let's continue to ./02-dynamism.md Bonsai Guide Part 2: Dynamism."],["guide@@02-dynamism@@values-and-computations","Guide","Dynamism","Values and computations","Dynamism is central to engaging applications: as the state of the world changes, so should the UI.The previous chapter introduced an immutable view type, Vdom.Node.t along with the idea that the UI is a function from data to view. For large and dynamic input data, this function is expensive and must run quite often. To keep up with quickly changing data, we would like to only re-compute the parts of the view that depend on newly changed data.This chapter takes a detour from the theme of computing web UIs to investigate the core Bonsai abstractions. It may be surprising to know that Bonsai isn't specialized for user interfaces; rather, it answers the very generic question of how to build composable incremental state-machines. As it turns out, incremental state-machines are a great abstraction for building UI! This chapter is more complicated than we might like due to a longstanding quirk of Bonsai's architecture. We'll begin by describing the more ideal way to think about Bonsai, and then we'll explain why it isn't quite accurate. Bonsai is all about constructing incremental state machine graphs. A 'a Value.t is a node in a graph that represents a 'a that changes over time. A 'a Computation.t is an entire graph that might contain many Value.t of different types, but culminates in a 'a Value.t . The motivation for having two types will be thoroughly explored later, but let us start with something basic: building a graph that computes a value that depends on two other values. ocaml let juxtapose_digits ~(delimiter : string) (a : int Value.t) (b : int Value.t) : string Computation.t = let%arr a = a and b = b in Int.to_string a ^ delimiter ^ Int.to_string b ;; The two phrases a = a and b = b may look a little silly, but they are necessary. The expression on the right-hand side of both bindings in the let%arr has type int Value.t , but the pattern on the left hand side is a plain old int that we can freely pass to Int.to_string . So let%arr is useful for \"unwrapping\" the data inside a Value.t so that we can access it for a limited scope.The type of the entire let%arr expression, which includes the stuff on both sides of in , is string Computation.t rather than string Value.t . This means that the result is a graph and not a node in a graph. To obtain the final node of a Computation.t graph, we can use a let%sub expression. ocaml let _juxtapose_and_sum (a : int Value.t) (b : int Value.t) : string Computation.t = let%sub juxtaposed = juxtapose_digits ~delimiter:\" + \" a b in let%sub sum = let%arr a = a and b = b in Int.to_string (a + b) in let%arr juxtaposed = juxtaposed and sum = sum in juxtaposed ^ \" = \" ^ sum ;; We provide a computation and let%sub provides a name we can use to refer to the result node of that computation. In the first let%sub above, the computation is juxtapose_digits a b and the name is juxtaposed . The important thing about using let%sub is that juxtaposed has type string Value.t , so we can freely use it in let%arr expressions.A subtle, yet extremely important aspect of let%sub is that it makes a copy of the input computation, and the node that the name refers to is the result node of that copy, rather than of the original. This means that if you use let%sub twice on the same computation, you get access to the result nodes for two independent copies of the same graph. All we've encountered so far are pure function computations constructed with let%arr , so having multiple copies of a graph is useless, since all the copies will always be producing identical results. The ability to copy is useful when computations contain internal state.The following example demonstrates how to use Bonsai.state , a primitive computation for introducing internal state to a computation. Notice that we get access to two result nodes: count is the state's current value and set_count is a function for updating that value. ocaml let (counter_button : Vdom.Node.t Computation.t) = let%sub count, set_count = Bonsai.state 0 in let%arr count = count and set_count = set_count in (* view-construction logic *) Vdom.Node.div [ Vdom.Node.text [%string \"Counter value: %{count#Int}\"] ; Vdom.Node.button ~attrs:[ Vdom.Attr.on_click (fun _ -> set_count (count + 1)) ] [ Vdom.Node.text \"increment count\" ] ] ;; Now we can illustrate the power of being able to instantiate a component twice. The following code demonstrates that we can use let%sub on counter_button to get three independent counters. ocaml let (three_counters : Vdom.Node.t Computation.t) = let%sub counter1 = counter_button in let%sub counter2 = counter_button in let%sub counter3 = counter_button in let%arr counter1 = counter1 and counter2 = counter2 and counter3 = counter3 in Vdom.Node.div [ counter1; counter2; counter3 ] ;; Every time we instantiate counter_button with let%sub , we get a Vdom.Node.t Value.t that represents the final result node of a copy of the counter_button computation graph. We use Vdom.Node.div to build a user interface that contains all three buttons so the user can click on them; however, first we need to use let%arr to get access to the view inside each counter graph node.The role of let%sub in Bonsai is similar to the new keyword in an object-oriented programming language. Just like new makes a brand new copy of the specified class with its own independent mutable fields, so also does let%sub make a brand new copy of the specified computation with its own independent internal state. In addition, just like new usually yields a reference/pointer (in languages like C# or Java) instead of the data itself, so also does let%sub yield merely the result node of the newly copied graph instead of the graph itself.We've introduced two basic kinds of computations - state, which may be introduced by Bonsai.state , and work, which may be introduced by let%arr . While these are certainly the most important, Bonsai provides primitive computations for a few other things, such as time-varying and edge-triggering computations.We've also introduced the primary means by which you construct larger computations from smaller ones - let%sub . Part of the learning curve of building Bonsai apps is getting comfortable composing together a bunch of little computations."],["guide@@02-dynamism@@the-scary-side-of-values","Guide","Dynamism","The scary side of values","The previous section intentionally did not explain that Value.t is an applicative, which means that it works with the let%map syntax, in addition to the let%arr syntax we've already introduced. The difference between the two is very small: let%arr expands to the expansion of let%map , except it wraps the entire thing in a call to return . The following ocaml skip let f (x : int Value.t) : int Computation.t = let%arr x = x in x + 1 expands to ocaml skip let f (x : int Value.t) : int Computation.t = return (let%map x = x in x + 1) which further expands to ocaml skip let f (x : int Value.t) : int Computation.t = return (Value.map x ~f:(fun x -> x + 1)) The Value.t applicative interface is scary because re-using the result of a let%map expression causes the work that it represents to be duplicated. Consider the following computation. ocaml let component (xs : int list Value.t) : string Computation.t = let sum = let%map xs = xs in List.fold xs ~init:0 ~f:( + ) in let average = let%map sum = sum and xs = xs in let length = List.length xs in if length = 0 then 0 else sum / length in let%arr sum = sum and average = average in [%string \"sum = %{sum#Int}, average = %{average#Int}\"] ;; We would like this computation to only do the work of computing sum once; however, every usage of sum entails an iteration through the list. Note that the final result depends on sum directly, but also indirectly through average ; this means that sum is computed twice in order to produce the formatted string.This explanation seems to contradict the explanation in the beginning of this chapter that computations are graphs and values are nodes in the graph. The truth is that values are also graphs, and re-using a value entails using another copy of that value's graph, thus duplicating any work contained in the graph. To avoid this work duplication, we can instantiate the value with let%sub , but since let%sub only instantiates computations, we must wrap the let%map inside a call to return . For consistency and robustness, we'll apply this transformation to average as well, even though it is only used once. ocaml let component (xs : int list Value.t) : string Computation.t = let%sub sum = return (let%map xs = xs in List.fold xs ~init:0 ~f:( + )) in let%sub average = return (let%map sum = sum and xs = xs in let length = List.length xs in if length = 0 then 0 else sum / length) in return (let%map sum = sum and average = average in [%string \"sum = %{sum#Int}, average = %{average#Int}\"]) ;; Before the introduction of let%arr , this was the idiomatic way of using Bonsai. However, now that let%arr exists, we can transform the above code into the following, exactly equivalent, computation: ocaml let component (xs : int list Value.t) : string Computation.t = let%sub sum = let%arr xs = xs in List.fold xs ~init:0 ~f:( + ) in let%sub average = let%arr sum = sum and xs = xs in let length = List.length xs in if length = 0 then 0 else sum / length in let%arr sum = sum and average = average in [%string \"sum = %{sum#Int}, average = %{average#Int}\"] ;; While the Value.t applicative can have surprising behavior, if you restrict yourself to only use let%sub and let%arr , then you won't ever accidentally duplicate work."],["guide@@02-dynamism@@inputs-to-the-graph","Guide","Dynamism","Inputs to the graph","Dynamic data flows into the graph through 'a Var.t , the third main type in Bonsai. A var is similar to a ref or the analogous 'a Incr.Var.t from incremental. ocaml type 'a t (** Creates a var with an initial value. *) val create : 'a -> 'a t (** Runs a function over the current value and updates it to the result. *) val update : 'a t -> f:('a -> 'a) -> unit (** Change the current value. *) val set : 'a t -> 'a -> unit (** Retrieve the current value. *) val get : 'a t -> 'a (** Get a value that tracks the current value, for use in a computation. *) val value : 'a t -> 'a Value.t The typical use-case for a var is that there is some source of ever-changing data, such as a Polling_state_rpc from a server. The Bonsai app will subscribe to these changes with a callback that updates the var with the new data that it received. The main app computation then receives the value-ified var after it has been passed through Var.value . Here is a concrete example: ocaml let counter_every_second : int Value.t = let counter_var : int Bonsai.Var.t = Bonsai.Var.create (-1) in every (Time_ns.Span.of_sec 1.0) (fun () -> Bonsai.Var.update counter_var ~f:(fun i -> i + 1)); Bonsai.Var.value counter_var ;; let view_for_counter : Vdom.Node.t Computation.t = let%arr counter = counter_every_second in Vdom.Node.textf \"counter: %d\" counter ;;"],["guide@@02-dynamism@@bonsai-is-a-compiler","Guide","Dynamism","Bonsai is a compiler","The Bonsai library does not provide the logic for stabilizing an incremental function and extracting the output value. Instead, it compiles the value and computation \"surface syntax\" into the \"assembly language\" provided by the Incremental library. Compilation happens once when the app starts up, and thereafter the main program only interacts with the app in Incr.t form.The Bonsai API is carefully designed to allow its compiler to statically analyze the entire graph. This is why we ../blogs/why_no_bind.md don't provide bind, since the callback passed to bind is an opaque function. There are few important consequences of the static analyzability of Bonsai graphs:Compilation to incremental nodes only needs to happen once, at startup. We can run \"whole-program analysis\" on the graph to optimize and seriously condense the computation graph. We have the ability to instrument each node in a computation with performance and debugging info. Eventually we plan to use this info to implement a debugger and profiler for Bonsai computations."],["guide@@03-state@@simple-state","Guide","State","Simple State","./02-dynamism.md Chapter 2 briefly touched on the fact that computations capture internal state. This chapter takes a deeper look at the primitives Bonsai provides for introducing and interacting with local state.The simplest kind of state is Bonsai.state . It returns both a value tracking the state's current model, and also a function for updating that model. ocaml skip val state : 'model -> ('model * ('model -> unit Effect.t)) Computation.t 'model : This is the initial value contained in the state, its \"default\" \"model\". Let's break down a simple, yet realistic usage of this computation. ocaml let textbox : (string * Vdom.Node.t) Computation.t = let%sub state, set_state = Bonsai.state \"\" in let%arr state = state and set_state = set_state in let view = Vdom.Node.input ~attrs: [ Vdom.Attr.value_prop state ; Vdom.Attr.on_input (fun _ new_text -> set_state new_text) ] () in state, view ;; The computation returns the current contents of a textbox, as well as the textbox view itself. The view could be combined with the views from other components, eventually becoming the view for the entire application. The \"current value\" could be passed on to other components (like we'll do later). In the Bonsai ecosystem, a function that takes any number of Value.t as input and returns a Computation.t is considered a \"component\". (In this example, \"textbox\" takes no Value.t as inputs, but zero is still \"any number\", so textbox is a component.) ocaml skip let%sub state, set_state = Bonsai.state \"\" in This line creates some string state initially containing the empty string. We use let%sub to instantiate this state, giving us access to state and set_state , which have types string Value.t and (string -> unit Effect.t) Value.t , respectively.The let%arr expression maps over two values to produce a computation containing the string and the view. If we attempted to write this code using state and set_state directly instead of through let%arr , the resulting program would not type-check, since both of these variables have Value.t types. let%arr is required in order to get access to the data inside the values.The actual construction of the textbox virtual-dom node is quite boring; we add the value_prop property to keep the textbox contents in sync, and also register an event handler for on_input , an event that fires when the text in the textbox changes. It is not obvious why value_prop is needed. If the contents of the textbox are populated by the user, why re-set them with the current state's value?The answer is complicated, but it boils down to the behavior of the component in weirder circumstances than these basic examples, likeThe set_state function is called by something other than the textbox on_input function. In this scenario, you'd want the contents of the textbox to change alongside the state . The textbox component is removed from the page and then added back again. If value_prop wasn't there, the textbox's default state would be empty! When the event does fire, the set_state function is called with the new string. set_state has type string -> unit Effect.t , which you may recognize from the last section in the ./01-virtual_dom.md virtual-dom chapter. This function is called with the new textbox contents, and the event which is returned schedules the state-setting in the Bonsai event queue.This is the payoff for the unanswered questions in ./01-virtual_dom.md the virtual-dom Chapter:How do I get values of type unit Effect.t that aren't just Ignore and Many : State-transition functions returned by stateful Bonsai components will return unit Effect.t s. Why would I want to use the Bonsai event queue anyway: More complex stateful components (like Bonsai.state_machine ) can witness the changes made to other stateful components, and the Bonsai event-queue guarantees that these updates occur in a consistent order and that downstream components witness changes made to upstream components."],["guide@@03-state@@multiple-textboxes","Guide","State","Multiple Textboxes","Now that we've built a single textbox component, let's use it in a bigger component: ocaml let two_textboxes : Vdom.Node.t Computation.t = let%sub textbox_a = textbox in let%sub textbox_b = textbox in let%arr contents_a, view_a = textbox_a and contents_b, view_b = textbox_b in let display = Vdom.Node.textf \"a: %s, b: %s\" contents_a contents_b in Vdom.Node.div ~attrs:[ Vdom.Attr.style (Css_gen.display `Inline_grid) ] [ view_a; view_b; display ] ;; This code is structurally very similar to the textbox component from earlier:It instantiates computations using let%sub (this time with the textbox component itself, rather than the primitive Bonsai.state computation). let%arr is used to build a computation by mapping over values previously bound by let%sub . Of particular note is that the textbox component is instantiated twice (using let%sub ). Because of this, each textbox will have its own independent state.Just for kicks, it's easy to see what would happen if the computation is evaluated once but used twice. In the following code, the only difference between it and the previous example is this line: diff - let%sub textbox_b = textbox in + let textbox_b = textbox_a in ocaml let two_textboxes_shared_state : Vdom.Node.t Computation.t = let%sub textbox_a = textbox in let textbox_b = textbox_a in let%arr contents_a, view_a = textbox_a and contents_b, view_b = textbox_b in let display = Vdom.Node.textf \"a: %s, b: %s\" contents_a contents_b in Vdom.Node.div ~attrs:[ Vdom.Attr.style (Css_gen.display `Inline_grid) ] [ view_a; view_b; display ] ;; Not very useful, but heartwarming that something sensible happens at all."],["guide@@03-state@@state-machine","Guide","State","State Machine","While Bonsai.state is quite useful, sometimes the state contained within an application more closely resembles a state-machine with well-defined transitions between states.Consider a \"counter\" component that stores (and displays) an integer, alongside buttons which increment and decrement that integer. This component can easily be implemented using Bonsai.state : ocaml let state_based_counter : Vdom.Node.t Computation.t = let%sub state, set_state = Bonsai.state 0 in let%arr state = state and set_state = set_state in let decrement = Vdom.Node.button ~attrs:[ Vdom.Attr.on_click (fun _ -> set_state (state - 1)) ] [ Vdom.Node.text \"-1\" ] in let increment = Vdom.Node.button ~attrs:[ Vdom.Attr.on_click (fun _ -> set_state (state + 1)) ] [ Vdom.Node.text \"+1\" ] in Vdom.Node.div [ decrement; Vdom.Node.textf \"%d\" state; increment ] ;; But there's a tricky bug hidden in this implementation: if a user clicks the button more than once within a span of 16-milliseconds, there's a chance that both button clicks will set the same value! This is because the \"current state\" value is closed over by the event handler, and this value could be stale because the DOM (including event handlers) is only updated once per frame (approx every 16ms). It's easy to say \"clicking on a button that fast isn't particularly likely\", and that may be true, but users are very fast with their keyboards, and using keyboard shortcuts to manipulate applications is common. In addition, if the application has an exceptionally long frame, then the user might accidentally click twice before the frame completes. Fortunately, Bonsai.state_machine0 is here to help! It has this type: ocaml val Bonsai.state_machine0 : (module Action with type t = 'action) -> default_model:'model -> apply_action: (inject:('action -> unit Effect.t) -> schedule_event:(unit Effect.t -> unit) -> 'model -> 'action -> 'model) -> ('model * ('action -> unit Effect.t)) Computation.t Compared to Bonsai.state , there are several similarities:A \"Model\" first-class-module is passed in, alongside the initial model value ( default_model ). The return value is a Computation.t that provides the current state alongside a function which schedules changes to the state. The main difference is the additional Action module, and apply_action . The apply-action parameter is a function with a fairly long signature, but can be simplified down to the last section: 'model -> 'action -> 'model . This encodes the notion of a state-machine transition: \"given the current model and an action, produce a new model.\" The inject and schedule_event parameters are rarely used. They are only useful when a state-transition needs to schedule another state transition, either for itself (by composing inject with schedule_event ) or for another state-machine (just calling schedule_event ). So how would we use state_machine0 to fix the bug in the counter application? ocaml module Action = struct type t = | Increment | Decrement [@@deriving sexp_of] end let counter_state_machine : Vdom.Node.t Computation.t = let%sub state, inject = Bonsai.state_machine0 () ~sexp_of_action:[%sexp_of: Action.t] ~default_model:0 ~apply_action:(fun (_ : _ Bonsai.Apply_action_context.t) model action -> match action with | Increment -> model + 1 | Decrement -> model - 1) in let%arr state = state and inject = inject in let decrement = Vdom.Node.button ~attrs:[ Vdom.Attr.on_click (fun _ -> inject Decrement) ] [ Vdom.Node.text \"-1\" ] in let increment = Vdom.Node.button ~attrs:[ Vdom.Attr.on_click (fun _ -> inject Increment) ] [ Vdom.Node.text \"+1\" ] in Vdom.Node.div [ decrement; Vdom.Node.textf \"%d\" state; increment ] ;; First, an Action module is defined as a sum type that lists all the operations that can be performed on the state-machine. This module is passed in to the call to state_machine0 . Then, the apply_action function is defined as a model-transformation function.Using the computation returned by state_machine0 also changes: instead of a \"set-state\" function, we get a function that \"injects\" our Action.t into a unit Effect.t .Now, when a button is clicked multiple times in quick succession, instead of calling set_state multiple times with the same value, Bonsai will call inject multiple times, and they'll be processed by apply_action in order, producing the correct result. state_machine0 has a \"0\" at the end to indicate that it takes \"0\" additional inputs. Compare the type signatures between state_machine0 and state_machine1 : diff -val state_machine0 +val state_machine1 : (module Action with type t = 'action) -> default_model:'model -> apply_action: (inject:('action -> unit Effect.t) -> schedule_event:(unit Effect.t -> unit) + -> 'input -> 'model -> 'action -> 'model) + -> 'input Value.t -> ('model * ('action -> unit Effect.t)) Computation.t The input is provided to the state-machine in 'input Value.t form, but is available inside the apply_action as a 'input . This allows the state-transition function to depend on the results of other computations.There is no state_machine2 , but implementing one would be trivial, by tupling the input Value.t , and destructuring the inputs inside apply_action ."],["guide@@03-state@@why-should-functional-programmers-be-okay-with-stateful-components","Guide","State","Why should functional programmers be okay with stateful components?","UI programming is inherently stateful. Even a UI element as simple as a textbox needs to keep some state around to store the current contents of the textbox.Many of the tools that functional programmers use for dealing with state almost exclusively involve moving that state out of their programs into a database, or by pulling mutable state out into a small part of the program. These strategies can keep the majority of programs relatively pure and easy to test, but sadly, they don't scale well to UI components for a few reasons:The stateful nature is something that is desirable to test! Bonsai needs to know when the state for a component changes so that it can re-fire calculations of down-stream components. If every component were provided a state-getter and state-setter, this would make component composition more manual work for the programmer; as applications get bigger and bigger, the root element would need to manage potentially dozens or hundreds of states for each transitive sub-component. Adding or removing state from a component would be a breaking change for everyone using it. One way to look at UI components is that they are portals through which an application interacts with the messy world. The job of a component is to translate the unpredictable user actions into a well-understood piece of data.Although the fact that components are stateful might injure your functional programming dogmatism, in fact, it is quite in line with functional programming principles, which aim to isolate effects. The most common way to isolate effects is by having a small kernel of effectful code invoke the pure majority of the logic; in other words, we isolate state by shifting it toward the root of the program. Bonsai offers an alternative tool for isolation. With Bonsai UI components, effectful code gets wrapped up and managed so that the interface provided by the component remains pure; in other words, we isolate state by shifting it toward the leaves of the program.On to ./04-forms.md Chapter 4: Forms."],["guide@@04-forms@@form-t","Guide","Forms","Form.t","Back in the ./03-state.md state chapter, a textbox component was built out of the low-level Bonsai primitives. Textboxes are an example of form elements, and they're very common in real-world applications. Because of this, Bonsai has an entire library dedicated to building and combining forms.The library is called bonsai_web_ui_form , and it is built on top of the same primitives that were used in the previous chapter.For the rest of this doc, this module alias will be in effect: ocaml module Form = Bonsai_web_ui_form The primary type in the forms library is 'a Form.t . A value of type 'a Form.t represents the state of a form at one particular instant in time, where the form in question can edit values of type 'a .Because of the inherently stateful nature of form UIs, it is common to find 'a Form.t inside of Computation.t . For example, a textbox form element that produces strings has this type: ocaml val Form.Elements.Textbox.string : Source_code_position.t -> string Form.t Computation.t And the type for a checkbox that produces bools has this type: ocaml val Form.Elements.Checkbox.bool : Source_code_position.t -> default:bool -> bool Form.t Computation.t There are three primary operations that can be performed on a 'a Form.t Extract the current value: val Form.value: 'a Form.t -> 'a Or_error.t Compute the view: val Form.view_as_vdom: 'a Form.t -> Vdom.Node.t Set the value of the form: val Form.set: 'a Form.t -> 'a -> unit Vdom.Effect.t The view_as_vdom function actually has an optional parameter, which we'll investigate soon. Let's look at them all in action, using the textbox component up above as an example: Form.value The \"value\" of a 'a Form.t is the current output of the form as filled in by the user. For a simple textbox, that value would be string , but most forms are compositions of subforms, so the produced value can be a record or variant.In the following example, the value of a textbox is extracted and printed as a sexp: <!-- $MDX file=../../examples/bonsai_guide_code/form_examples.ml,part=form_textbox_value --> {=html} ocaml let textbox_value = let%sub textbox = Form.Elements.Textbox.string () in let%arr textbox = textbox >>| Form.label \"my textbox\" in let value = Form.value textbox in Vdom.Node.div [ Form.view_as_vdom textbox ; Vdom.Node.sexp_for_debugging ([%sexp_of: string Or_error.t] value) ] ;; Forms returning their values inside of an Or_error.t may be surprising at first, but in practice, more complex forms are fallible, either because form validation for an element has failed, or because a large form is only partially filled out. By making the assumption that all forms are fallible, the rest of the API is simpler. Form.view_as_vdom This one is pretty simple, view_as_vdom renders the form into a Vdom.Node.t . However, it also has an optional parameter that makes submitting the form easier. Its full type signature is: ocaml module Submit : sig type 'a t val create : ?handle_enter:bool -> ?button:string option -> f:('a -> unit Ui_effect.t) -> unit -> 'a t end val view_as_vdom : ?on_submit:'a Submit.t -> 'a t -> Vdom.Node.t Because forms are frequently paired with a \"submit\" button, the optional submission options provide an easy way to submit the form, with the f field being called with the value of the fully-validated form. The two options for submitting the form are handle_enter , when true will cause the form to be submitted whenever the <enter> key is pressed while focusing on a form element inside this form. button , if Some , a button with the provided text will be added to the form. This button will be disabled whenever the form is in an error state, but when the form is valid, the button will be enabled and will trigger the submission function when pressed. ocaml let textbox_on_submit = let%sub textbox = Form.Elements.Textbox.string () in let%arr textbox = textbox in textbox |> Form.label \"text to alert\" |> Form.view_as_vdom ~on_submit:(Form.Submit.create () ~f:alert) ;; Form.set Setting the contents of a form is a rarer requirement. Most forms are read-only (the user is the only one filling it out), but sometimes, a form should be modified by the program, perhaps to initialize the form in a specific state. ocaml let form_set = let%sub textbox = Form.Elements.Textbox.string () in let%arr textbox = textbox >>| Form.label \"my textbox\" in Vdom.Node.div [ Form.view_as_vdom textbox ; Vdom.Node.button ~attrs:[ Vdom.Attr.on_click (fun _ -> Form.set textbox \"hello world\") ] [ Vdom.Node.text \"click me\" ] ] ;;"],["guide@@04-forms@@combinators","Guide","Forms","Combinators","Most forms contain many input elements, and Bonsai-Forms comes with a set of combinators for combining many smaller subforms into a larger form.For this example, we'll build a form for the following type: ocaml type t = { some_string : string ; an_int : int ; on_or_off : bool } [@@deriving typed_fields, sexp_of] Building a form that produces values of this type requires the use of the typed_fields ppx, which you'll need to add to your jbuild. Deriving typed_fields will make a module named Typed_field containing a type with a constructor representing each field in the record it was derived on. ocaml let form_of_t : t Form.t Computation.t = Form.Typed.Record.make (module struct (* reimport the module that typed_fields just derived *) module Typed_field = Typed_field let label_for_field = `Inferred (* provide a form computation for each field in the record *) let form_for_field : type a. a Typed_field.t -> a Form.t Computation.t = function | Some_string -> Form.Elements.Textbox.string () | An_int -> Form.Elements.Number.int ~default:0 ~step:1 () | On_or_off -> Form.Elements.Checkbox.bool ~default:false () ;; end) ;; We can also do the same for variants with [@@deriving typed_variants] . ocaml type v = | A | B of int | C of string [@@deriving typed_variants, sexp_of] let form_of_v : v Form.t Computation.t = Form.Typed.Variant.make (module struct (* reimport the module that typed_fields just derived *) module Typed_variant = Typed_variant_of_v let label_for_variant = `Inferred let initial_choice = `First_constructor (* provide a form computation for constructor in the variant *) let form_for_variant : type a. a Typed_variant.t -> a Form.t Computation.t = function | A -> Bonsai.const (Form.return ()) | B -> Form.Elements.Textbox.int () | C -> Form.Elements.Textbox.string () ;; end) ;; Finally, using this new form and printing the results: ocaml let view_for_form : Vdom.Node.t Computation.t = let%sub form_t = form_of_t in let%sub form_v = form_of_v in let%arr form_t = form_t and form_v = form_v in let form = Form.both form_t form_v in let value = Form.value form in Vdom.Node.div [ Form.view_as_vdom form ; Vdom.Node.sexp_for_debugging ([%sexp_of: (t * v) Or_error.t] value) ] ;;"],["guide@@04-forms@@validation-parsing","Guide","Forms","Validation Parsing","Notably missing in the Forms API is a \"map\" function. In its place is Form.project , which has this type signature: ocaml val project : 'a t -> parse_exn:('a -> 'b) -> unparse:('b -> 'a) -> 'b t project is a way to move from a form producing values of type 'a to a form producing values of type 'b , but it requires two \"mapping\" functions, parse_exn , which moves from 'a to 'b as you'd expect, but the other, unparse , goes in the opposite direction! unparse is required because Form.set needs to be able to accept values of type 'b and route them through the setter for the input form.In practice, project is used to build forms for types that can be parsed from other types. For example, if Form.Elements.Textbox.int didn't exist, we could implement it like so: ocaml let int_textbox : int Form.t Computation.t = let%sub form = Form.Elements.Textbox.string () in let%arr form = form in Form.project form ~parse_exn:Int.of_string ~unparse:Int.to_string ;; You'll notice that non-integers are reported as an error. Form.project actually captures the exception thrown by Int.of_string and the Form.value returned by the project ed form is an Error .On to ./05-effect.md Chapter 5: Effect"],["guide@@05-effect@@making-an-effect","Guide","Effect","Making an Effect","As we saw back in the ./03-state.md chapter about state, values with type unit Vdom.Effect.t are used to schedule updates to stateful components. However, the Effect.t type can also be used to perform arbitrary side-effectful actions that return values. Most commonly, these side effects involve calling RPCs.A 'a Effect.t represents a side effect which, when performed, produces a value of type 'a .There's a lot of overlap between 'a Effect.t and 'a Deferred.t :Both are (likely) performing side effects (like calling RPCs) They produce values of type 'a when completed This result can be computed at some point in the future So it's important to note one major difference between 'a Effect.t and 'a Deferred.t : when bound (via let%bind ) multiple times, a Deferred will execute its side effect exactly once, but an Effect will side effect as many times as it is bound .This difference exists for both theoretical and practical purposes.On the theoretical side, Deferred.t , at its core, represents a value that will be computed at some point in the future (and may perform side effects in order to calculate that value), while Effect.t is a first-class representation of the side effect itself, which happens to produce a value.On the practical side, Deferred.t just doesn't mesh with the incremental computational model that Bonsai provides. In particular, a value of type 'a Deferred.t Value.t is quite hard to use correctly, as Bonsai has no way of knowing that the value contained inside is a Deferred, and it won't re-compute when the deferred is completed. {=html} <!-- Also, unit tests for Bonsai\\_web applications require compiling to JavaScript, and our JavaScript expect-test library is not capable of running Async tests, so `Effect.t` is used with synchronous functions to test apps that will use asyncronous functions in production. --> The main use-case for Effect is for exposing RPCs to the Bonsai application, so for the rest of this document, we're going to be interacting with a function that has this type signature, which we'll pretend is an RPC: ocaml val uppercase : string -> string Deferred.t Turning uppercase into a function that returns an Effect is easy with Bonsai_web.Effect.of_deferred_fun ocaml val of_deferred_fun : ('query -> 'response Deferred.t) -> 'query -> 'response t of_deferred_fun is defined inside Bonsai_web instead of just Bonsai because Bonsai doesn't depend on Async . All the rest of the Effect functions are in Bonsai.Effect (but re-exported for Bonsai_web.Effect ). Using Bonsai_web.of_deferred_fun , we can make a new function that returns an Effect.t instead of Deferred.t ocaml let uppercase_e : string -> string Effect.t = Bonsai_web.Effect.of_deferred_fun uppercase"],["guide@@05-effect@@using-effects","Guide","Effect","Using Effects","By converting a deferred-returning function to return an effect, we can more easily compose it with other Bonsai APIs, like event handlers.In the following example, we have a textbox, a button, and a \"results\" display. We want to use the uppercase_e event-returning function from above to compute the uppercased value of the contents of the textbox when the button is clicked.The first implementation looks like this. ocaml module Request_state = struct type t = | Empty | Pending | Filled of string [@@deriving sexp, equal] let to_string = function | Empty -> \"<no request sent>\" | Pending -> \"pending...\" | Filled s -> s ;; end let uppercase_rpc_sender = let%sub textbox = Forms.Elements.Textbox.string () in let%sub result_state = Bonsai.state Empty ~sexp_of_model:[%sexp_of: Request_state.t] ~equal:[%equal: Request_state.t] in let%arr textbox = textbox and result_state, set_result = result_state in let on_submit (contents : string) : unit Effect.t = let%bind.Effect s = uppercase_e contents in set_result (Filled s) in let form_view = textbox |> Forms.label \"text to capitalize\" |> Forms.view_as_vdom ~on_submit:(Forms.Submit.create ~f:on_submit ()) in Vdom.Node.div ~attrs:[ Vdom.Attr.style (Css_gen.display `Inline_grid) ] [ form_view; Vdom.Node.text (Request_state.to_string result_state) ] ;; Please note that the \"Pending\" state is not used (yet!) Let's zoom in on the on_submit handler: ocaml let on_submit (contents : string) : unit Effect.t = let%bind.Effect s = uppercase_e contents in set_result (Filled s) By calling the uppercase_e function, a string Effect.t is returned. Binding on that value gives us (at some point in the future) the result of the operation, which we immediately pass through to update the state of our component.But as mentioned above, the \"Pending\" state was never used. We can implement that by adding another bind to the effect, setting \"Pending\" immediately. ocaml let on_submit (contents : string) : unit Vdom.Effect.t = let open Bonsai.Effect.Let_syntax in let%bind () = set_result Pending in let%bind s = uppercase_e contents in set_result (Filled s) Next, read the ../blogs/testing.mdx chapter on testing."],["guide@@07-flow@@components-as-dags","Guide","Flow","Components as DAGs","This chapter of the guide is a collection of smaller topics that are valuable for structuring components.One of the biggest differences between Bonsai and other virtual-dom based UI frameworks (such as React, Vue, or Elm) is that Bonsai structures the composition of UI components as a Directed Acyclic Graph instead of as a tree.What this means in practice is that the output of one component can be fed as input to another component.To illustrate this, we'll build a textbox component whose placeholder text is specified dynamically. This textbox component is so similar to the one constructed in the ./03-state.md state chapter that the diff between that version and the new one is shown below for convenience. diff -let textbox = +let textbox ~placeholder = let%sub state, set_state = Bonsai.state (module String) ~default_model:\"\" in (let%arr state = state and set_state = set_state + and placeholder = placeholder in let view = Vdom.Node.input ~attr:(Vdom.Attr.many [ Vdom.Attr.value_prop state ; Vdom.Attr.on_input (fun _ new_text -> set_state new_text) + ; Vdom.Attr.placeholder placeholder ]) () in state, view) ;; And a basic usage of the new component (with a constant placeholder) ocaml let textbox_with_placeholder = textbox ~placeholder:(Value.return \"the placeholder\") And because of the graph-like structure of a Bonsai app, we can trivially chain two textboxes together so that the contents of one of the output of one textbox is used as the placeholder for the next. ocaml let textbox_chaining = let%sub a_contents, a_view = textbox ~placeholder:(Value.return \"\") in let%sub _, b_view = textbox ~placeholder:a_contents in let%arr a_view = a_view and b_view = b_view in let style = Vdom.Attr.style (Css_gen.display `Inline_grid) in Vdom.Node.div ~attrs:[ style ] [ a_view; b_view ] ;; Clearly, chaining together two textboxes to set the placeholder text isn't particularly useful (the examples are small though!), but in real applications, this kind of component dependency structuring is valuable in a myriad of ways:The output of a \"tab-selector\" component could include the view for a tab-bar, but also a value for the currently selected tab. Then other components could read that value and respond accordingly. A form could dynamically change its contents based on the values of previously filled out form contents. At the top of an application component graph, a \"light mode or dark mode\" checkbox component could be added, and the current value (either light or dark) could be passed down to downstream components to influence the way that they display."],["guide@@07-flow@@matchsub","Guide","Flow","match%sub","let%sub should be familiar to you by now, but there's actually a more powerful form of variable substitution which permits a limited form of dynamism, match expressions! With match%sub , a 'a Value.t is matched on, and any bindings in the match arm are projected out into their Value.t form. Let's look at what that means in practice!In the following example, we'll avoid building the 2nd textbox if the first textbox is either empty or only contains whitespace. ocaml let textbox_matching = let%sub a_contents, a_view = textbox ~placeholder:(Value.return \"\") in let%sub a_contents = let%arr s = a_contents in let s = String.strip s in if String.is_empty s then None else Some s in match%sub a_contents with | None -> let%arr a_view = a_view in let message = Vdom.Node.div [ Vdom.Node.text \"<a is empty>\" ] in Vdom.Node.div [ a_view; message ] | Some placeholder -> let%sub _, b_view = textbox ~placeholder in let%arr a_view = a_view and b_view = b_view in let style = Vdom.Attr.style (Css_gen.display `Inline_grid) in Vdom.Node.div ~attrs:[ style ] [ a_view; b_view ] ;; There are a few details to note about some of the types up aboveThe matched value has type 'a Value.t The values produced by each of the match-arms must be of type 'b Computation.t The overall type of the match%sub expression has type 'b Computation.t Any identifiers bound during matching (in the above example, this is just placeholder ) are available in Value.t form. It is important to know that at any point in time, only one of the arms in the pattern match is active, so the components in the not-matched arms are not being computed.In addition to match%sub , if%sub also exists, with the exact same semantics, but specialized for booleans."],["guide@@07-flow@@bonsai-assoc","Guide","Flow","Bonsai.assoc","Up until now, Bonsai hasn't had any real tools for dealing with dynamically sized collections of components. Sure, you could manually re-use a text-box component twice, but if the number of distinct components is determined at runtime, writing out a bunch of let%sub won't cut it.That's where Bonsai.assoc comes in. Let's start by looking at its type signature: ocaml val assoc : ('key, 'cmp) comparator -> ('key, 'data, 'cmp) Map.t Value.t -> f:('key Value.t -> 'data Value.t -> 'result Computation.t) -> ('key, 'result, 'cmp) Map.t Computation.t Breaking the parts of the signature down one-by-one we have ('key, 'cmp) comparator : A comparator is required; this is typically just (module Int) or (module My_type) where the type is comparable, and has the sexp functions defined. ('key, 'data, 'cmp) Map.t Value.t : A dynamic map from 'key to 'data . a named function f with type 'key Value.t -> 'data Value.t -> 'result Computation.t ; this function will be called with every key-value pair in the map, and produces a computation containing 'result . Finally, the return value of assoc is ('key, 'result, 'cmp) Map.t Computation.t , a map from the same key as the input to the 'result produced in the f function. This type signature is remarkably close to the regular OCaml function Map.mapi , which has this type signature: ocaml val mapi : ('key, 'data, 'cmp) Map.t -> f:(key:'key -> data:'data -> 'result) -> ('key, 'result, 'cmp) Map.t But of course the Bonsai version has a bunch of Value.t and Computation.t in it's type signature, so what are those types giving us?The first benefit to assoc is that the computation inside of f is only evaluated once per key/value pair, after which any updates to the data travel through the regular bonsai Value graph optimization. This means that if the input map is 100,000 elements large, but only one of the keys has data that is changing frequently, only the one component for that key will be involved in recomputing the eventual result of the overall function.The other benefit to using assoc is apparent from looking at the type of the function: the f function returns a Computation.t , which means that every key/value pair in the output map is its own component, each with it's own independent state!For this example, we'll re-use the \"counter\" component defined in the last section of the ./03-state.md state chapter, but this time, there'll be a bunch of them! ocaml let multiple_counters (input : unit String.Map.t Value.t) = let%sub counters = Bonsai.assoc (module String) input ~f:(fun _key (_ : unit Value.t) -> State_examples.counter_state_machine) in let%arr counters = counters in Vdom.Node.table (counters |> Map.to_alist |> List.map ~f:(fun (key, vdom) -> let open Vdom.Node in let name = td [ Vdom.Node.text key ] in let counter = td [ vdom ] in Vdom.Node.tr [ name; counter ])) ;; and to start out with we'll use a constant map as an input to the component: ocaml let multiple_counters_constant = multiple_counters ([ \"hello\", (); \"there\", () ] |> Map.of_alist_exn (module String) |> Value.return) ;; and while this does show off how to associate a component across a map, using Value.return makes it hard to see the \"dynamic\" aspect. So let's build a dynamically editable map! This final code example is less about Bonsai.assoc and more about integrating concepts from the rest of the bonsai guide: Bonsai.state_machine tracks and edits a map for the counters Bonsai's Forms library is used to interact with the state-machine to add new entries assoc builds up the table of counters from the map inside state-machine. ocaml module Model = struct type t = unit String.Map.t [@@deriving sexp, equal] let default = String.Map.of_alist_exn [ \"Dave\", (); \"Jill\", () ] end module Action = struct type t = | Add of string | Remove of string [@@deriving sexp_of] end let people = Bonsai.state_machine0 () ~sexp_of_model:[%sexp_of: Model.t] ~equal:[%equal: Model.t] ~sexp_of_action:[%sexp_of: Action.t] ~default_model:Model.default ~apply_action:(fun (_ : _ Bonsai.Apply_action_context.t) model action -> match action with | Add name -> Map.set model ~key:name ~data:() | Remove name -> Map.remove model name) ;; let add_new_person_form ~inject_add_person = let%sub form = Form.Elements.Textbox.string () in let%arr form = form and inject_add_person = inject_add_person in let on_submit name = Vdom.Effect.Many [ Form.set form \"\"; inject_add_person name ] in form |> Form.label \"name\" |> Form.validate ~f:(fun name -> if String.for_all name ~f:Char.is_whitespace then Error (Error.of_string \"name must not be empty\") else Ok ()) |> Form.view_as_vdom ~on_submit:(Form.Submit.create ~f:on_submit ()) ;; let people_table people ~inject_remove_person = Bonsai.assoc (module String) people ~f:(fun name (_ : unit Value.t) -> let%sub counter = State_examples.counter_state_machine in let%arr counter = counter and name = name and inject_remove_person = inject_remove_person in let open Vdom.Node in let remove_person = td [ button ~attrs:[ Vdom.Attr.on_click (fun _ -> inject_remove_person name) ] [ text \"x\" ] ] in let name = td [ text name ] in let counter = td [ counter ] in tr [ name; counter; remove_person ]) ;; let kudo_tracker = let%sub people, inject_action = people in let%sub form = let%sub inject_add_person = let%arr inject_action = inject_action in fun name -> inject_action (Add name) in add_new_person_form ~inject_add_person in let%sub people_table = let%sub inject_remove_person = let%arr inject_action = inject_action in fun name -> inject_action (Remove name) in people_table people ~inject_remove_person in let%arr people_table = people_table and form = form in let open Vdom.Node in div [ h2 [ text \"kudos tracker\" ] ; table [ thead [ tr [ th [ text \"Name\" ]; th [ text \"# Kudos\" ]; th [ text \"Remove\" ] ] ] ; tbody (Map.data people_table) ] ; h2 [ text \"Add Person\" ] ; form ] ;;"],["guide@@08-css@@handwritten-css-files","Guide","Css","Handwritten .css Files","Styling an application is very important. Not only is it critical for making an app look good, but \"styling\" is also responsible for component layout.However, there are a few different ways to include style information in your app or library, each with their own tradeoffs:Hand-written .css files style properties in vdom nodes ppx_css for inline stylesheets Using .css files to style components and pages is very common in web development. The Mozilla Developer Network has a very good https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/CSS_basics introductory tutorial on CSS if you aren't already familiar with it. Google also has a https://web.dev/learn/css/ comprehensive tutorial.At its core, a css stylesheet is a language for pattern-matching on DOM tree structure combined with a set of rules that should be applied to matching elements.With this css: <!-- $MDX skip --> {=html} css table { border-collapse: collapse; } table td { padding: 4px; } table thead { text-align: center; background: brown; color: antiquewhite; font-weight: bold; } table tr { background: antiquewhite; } table tr:nth-child(even) { background: wheat; } And some basic table code, we get a pretty table! ocaml type row = { id : int ; name : string ; age : int } let basic_table rows = let open Vdom.Node in let thead = thead [ td [ text \"id\" ]; td [ text \"name\" ]; td [ text \"age\" ] ] in let tbody = rows |> List.map ~f:(fun { id; name; age } -> tr [ td [ textf \"%d\" id ]; td [ text name ]; td [ textf \"%d\" age ] ]) |> tbody in table [ thead; tbody ] ;; let politicians = basic_table [ { id = 0; name = \"George Washington\"; age = 67 } ; { id = 1; name = \"Alexander Hamilton\"; age = 47 } ; { id = 2; name = \"Abraham Lincoln\"; age = 56 } ] ;; By keeping the styling logic and vdom-node production separate, our css can be quite high-level. Sadly, the \"high level description\" of the pattern for this table might be more broad than we had hoped; this css will style every table in our application, even those created by other components that you might not own!A common fix for this problem is to make the patterns more specific by adding a unique class name targeting just the tables that we want. For example: diff - table { + table.politicians { border-collapse: collapse; } - table td { + table.politicians td { padding: 4px; } - table thead { + table.politicians thead { text-align: center; background: brown; color: antiquewhite; font-weight: bold; } - table tr { + table.politicians tr { background: antiquewhite; } - table tr:nth-child(even) { + table.politicians tr:nth-child(even) { background: wheat; } and then in the table production code, diff - table [ thead; tbody ] + table ~attr:(Vdom.Attr.class_ \"politician\") [ thead; tbody ] This solves the issue of our styles inadvertantly obliterating other people's components, but comes at the cost of verbosity. It also isn't completely foolproof: if two people pick the same identifier (in this case we went with politician ), then the clash would still occur. This leads to people using very long and descriptive identifiers to reduce the odds of a collision.Another downside is that if you're an application author pulling in a UI component which has a stylesheet, then you need to somehow get that css file into your application. Typically this is done by writing a dune rule that concatenates your application's stylesheet with the stylesheets of any dependencies, like so: lisp (rule ( (targets (style.css)) (deps (%{root}/lib/dygraph/dist/dygraph.css ./my_styles.css)) (action \"cat %{deps} > %{target}\"))) If a component requires a stylesheet, there is no way of knowing that fact (other than by reading the readmes, but who does that?).ProsFull access to CSS language including pseudoselectors (like :nth-child(even) , or :hover ) Good debugging support in Chrome Devtools ConsIdentifier collisions can break things in subtle ways Reusable components that rely on a css stylesheet force the application author to use css files and to build out the dune rule for concatenating all of their dependencies' css."],["guide@@08-css@@vdom-attr-style","Guide","Css","Vdom.Attr.style","Another way to add styling to DOM nodes is through an individual DOM node's style property. Vdom.Attr.style has this type signature: Css_gen.t -> Vdom.Attr.t , so we'll be primarily looking at the Css_gen .A Css_gen.t is a collection of key-value pairs of css properties and their values. As an example, ocaml let style: Css_gen.t = Css_gen.text_align `Center is a style that only contains the kv-pair text-align: center; . Meanwhile, ocaml let style: Css_gen.t = let open Css_gen in text_align `Center @> background_color (`Name \"red\") makes use of the @> operator in order to merge two Css_gen.t s, producing kv-pairs which contain text-align: center; background: red; .If we ported the table example to use the inline style attribute, our code would now look like this: ocaml type row2 = { id : int ; name : string ; age : int } let table_styles = let open Css_gen in border_collapse `Collapse @> border ~style:`Solid ~color:(`Name \"brown\") ~width:(`Px 1) () ;; let thead_styles = let open Css_gen in text_align `Center @> background_color (`Name \"brown\") @> color (`Name \"antiquewhite\") @> font_weight `Bold ;; let tr_odd = Css_gen.background_color (`Name \"antiquewhite\") let tr_even = Css_gen.background_color (`Name \"wheat\") let td_styles = Css_gen.padding ~top:(`Px 4) ~bottom:(`Px 4) ~left:(`Px 4) ~right:(`Px 4) () ;; let basic_table_attr rows = let open Vdom.Node in let thead = thead ~attrs:[ Vdom.Attr.style thead_styles ] [ td [ text \"id\" ]; td [ text \"name\" ]; td [ text \"age\" ] ] in let tbody = rows |> List.mapi ~f:(fun i { id; name; age } -> let tr_style = if Int.( % ) i 2 = 0 then tr_even else tr_odd in tr ~attrs:[ Vdom.Attr.style tr_style ] [ td ~attrs:[ Vdom.Attr.style td_styles ] [ textf \"%d\" id ] ; td ~attrs:[ Vdom.Attr.style td_styles ] [ text name ] ; td ~attrs:[ Vdom.Attr.style td_styles ] [ textf \"%d\" age ] ]) |> tbody in table ~attrs:[ Vdom.Attr.style table_styles ] [ thead; tbody ] ;; let politicians = basic_table_attr [ { id = 0; name = \"George Washington\"; age = 67 } ; { id = 1; name = \"Alexander Hamilton\"; age = 47 } ; { id = 2; name = \"Abraham Lincoln\"; age = 56 } ] ;; Because we're no longer using a css file, the first part of the file re-defines all of the styling in OCaml using Css_gen . However, these styles are not applied automatically, so we also need to add calls to Vdom.Attr.style everywhere.In a particularly egregious case, we changed from using List.map to List.mapi , which allowed us to check if the row is even or odd, something that was previously done for us by our stylesheet. This brings us to our first major drawback of using inline style attributes: pseudo-selectors are unavailable. Some of these, like :nth-child , are implementable in our view-calculation logic because we're manually constructing the lists anyway. However, other pseudo-selectors like :hover or :focus are impossible, and others, like :nth-of-type are possible, but hair-pullingly annoying.ProsNo need to worry about identifier clashes because styles are stuck directly on the nodes themselves. If used in a library, the styles come with the library instead of being another css file that library users need to know about and manage. ConsMuch more verbose. Many css-attributes are missing from the Css_gen library (you can work around this with Css_gen.create ). Pseudo-selectors just aren't available."],["guide@@08-css@@css-ppx","Guide","Css","CSS Ppx","The third option is to use a brand new ppx: ppx_css ! With this ppx, you can write css code in your .ml files, and it will be loaded into the document at page-load. To use the ppx, add it to your jbuild like so: diff (executables ( (names (main)) (libraries (bonsai_web)) + (preprocess (pps (ppx_jane ppx_css))) (js_of_ocaml ()))) And now you can bind a module to the result of a css ppx invocation: ocaml module Style = [%css stylesheet {| table.politicians { border-collapse: collapse; border: 1px solid brown; } table.politicians td { padding: 4px; } table.politicians thead { text-align: center; background: brown; color: antiquewhite; font-weight: bold; } table.politicians tr { background: antiquewhite; } table.politicians tr:nth-child(even) { background: wheat; } |}] This is the exact same css from the second example! Notice that it still has a \"politicians\" class before every rule. With this new Style module bound, we can almost keep the same ocaml view generation as we had originally: ocaml let table_with_ppx_css rows = let open Vdom.Node in let thead = thead [ td [ text \"id\" ]; td [ text \"name\" ]; td [ text \"age\" ] ] in let tbody = rows |> List.map ~f:(fun { id; name; age } -> tr [ td [ textf \"%d\" id ]; td [ text name ]; td [ textf \"%d\" age ] ]) |> tbody in table ~attrs:[ Style.politicians ] [ thead; tbody ] ;; The only difference between this function and the first one we wrote is this: diff - table ~attr:(Vdom.Attr.class_ \"politicians\") [ thead; tbody ] + table ~attr:(Vdom.Attr.class_ Style.politicians) [ thead; tbody ] This Style.politicians value was generated by the ppx because it noticed that we were using it as a class-name. The ppx will also uniquify all of the class names and ids that it finds in the stylesheet. As an example, the first rule's selector will become table.politicians_hash_e82ee99238 , where the unique name is generated by hashing the contents of the css string as well as the path to the file containing the ppx. This means that Style.politicians is a string with the value politicians_hash_e82ee99238 , which we use for the classname.This kind of identifier hashing is useful because it means that component authors don't need to worry about collisions."],["guide@@08-css@@rewrite-flag","Guide","Css","[~rewrite] flag","Sometimes, like when interacting with customization APIs that require specific classnames for CSS customization, ppx_css's hygenic identifier hashing could get in your way. With [~rewrite], you get to choose the name for an identifier rather than ppx_css choosing - or rather hashing - it for you. ocaml (* A table library's customization API _needs_ users to style the \"table-header\" class. *) stylesheet {|.table-header {...}|} You can disable hashing when needed by using the optional ~rewrite parameter. ocaml (* Scenario: A table library's customization API _needs_ users to style the \"table-header\" class. *) stylesheet ~rewrite:[\"table-header\", \"table-header\"] {|.table-header {...}|} The above segment will \"rewrite\" table-header into table-header overriding the default hashing behavior.Some other times, you might still want hygenic hashing, but need the same identifier to have the same hash between two specific [%css stylesheet] invocations. Here are some examples of the rewrite flag in action: ocaml stylesheet ~rewrite:[ \"table-header\", \"table-header\"; \"table_row\", \"table-row\" ] {|...|} (* Rewrites multiple identifiers at once. *) stylesheet ~rewrite:[ \"my_table\", My_table_component.table ] {|...|} (* References an identifier defined in another module *) |xxx}];"],["guide@@08-css@@theming-through-ppx-css","Guide","Css","Theming through PPX CSS","One additional benefit is that this ppx/inliner opens up doors for allowing components to be customized by their users. The Style module that the ppx derived actually has this signature: ocaml sig module type S = sig val politicians : string end type t = (module S) val default : t val politicians : string end While we were just using the default politicians value, the module type and a default packed module implementing that module type are intended to be used for making it easy for component authors to allow their users to theme the components.By tweaking the code slightly we can see how this is possible: diff - let table_with_ppx_css rows = + let table_with_ppx_css ?(theme=Style.default) rows = + let module Style = (val theme) in let open Vdom.Node in let thead = thead [ td [ text \"id\" ]; td [ text \"name\" ]; td [ text \"age\" ] ] in let tbody = rows |> List.map ~f:(fun { id; name; age } -> tr [ td [ textf \"%d\" id ]; td [ text name ]; td [ textf \"%d\" age ] ]) |> tbody in table ~attr:(Vdom.Attr.class_ Style.politicians) [ thead; tbody ] ;; now someone could make a new module which implements that type: ocaml module My_theme = [%css stylesheet {| table.politicians { border-collapse: collapse; border: 1px solid black; } table.politicians td { padding: 4px; } table.politicians thead { text-align: center; background: black; color: white; font-weight: bold; } table.politicians td { border: 1px solid black; } |}] let table = themeable_table ~theme:(module My_theme) [ { id = 0; name = \"George Washington\"; age = 67 } ; { id = 1; name = \"Alexander Hamilton\"; age = 47 } ; { id = 2; name = \"Abraham Lincoln\"; age = 56 } ] ;; Due to the nature of the generated code, there are a few restrictions on the person building a custom theme:No new identifiers are allowed. This means that if a component author uses a dumb name like \"politicians\", then a theme author needs to as well. All identifiers present in the component definition must be used. You can use an empty rule like .politicians {} in order to meet this requirement if you wanted to avoid themeing something. These restrictions may seem onerous, but it's a lot like using a record in OCaml: the author of the record gets to decide what the names of the fields are, and if someone wants to construct a value of that record, they can't just leave out the fields that they don't care about. This means that component authors should think ahead and ask themselves \"what kind of customizability will users of this component want?\" before settling on a set of identifiers and picking which nodes they're attached to.There are (plans for) other kinds of ppx transformations other than just the identifier re-writing, such as automatically introducing the namespacing classnames for you. Those aren't here yet, but they might be soon.It should be noted that even with the classname hashing, it's still possible to write rules that affect more than you might like. I actually included a number of bugs of this form in the examples so far (!). .table.politicians td affects every td inside of the table, even tables within tables. So if one of the cells of this table contained another table that was styled differently, we'd run the risk of overwriting it. The \"correct\" rule in this case would be to fully qualify the paths to the elements, so table.politicians td would become table.politicians > tbody > tr > td .ProsFull access to CSS language including pseudoselectors (like :nth-child(even) , or :hover ) Good debugging support in Chrome Devtools No need to worry about identifier clashes because these identifiers are hashed before being used. If used in a library, the styles come with the library instead of being another css file that library users need to know about and manage. ConsIt's still up to you to make sure that styles aren't too general (this is going to be addresed in further releases of the ppx."],["guide@@09-edge-triggering@@after_display","Guide","Edge Triggering","after_display","Bonsai encourages declarative UI construction. A computation is defined as a list of dependencies and a function which reads the current value of those dependencies, producing a new value. A computation defined in this way doesn't care what the previous values of its dependencies were; it always operates on their current value.However, sometimes it can be helpful to witness a transition from one value to another. In Bonsai, we have the https://ocaml.org/p/bonsai/v0.15.0/doc/Bonsai/Edge/index.html Bonsai.Edge module, which has a collection of functions which can notice things likethe passage of time the activation and deactivation of components changing of the contents of a Value.t and schedule Effects when they occur.The main Edge function we'll take a look at is Bonsai.Edge.lifecycle , which takes a number of optional parameters of type unit Effect.t Value.t . The first of these is after_display . Edge.lifecycle schedules the effect passed in via after_display as the last operation in the Bonsai render-loop, right after the DOM has been updated. ocaml let frame_counter = let%sub frames, set_frames = Bonsai.state 0 in let%sub () = Bonsai.Edge.lifecycle ~after_display: (let%map frames = frames and set_frames = set_frames in set_frames (frames + 1)) () in let%arr frames = frames in Vdom.Node.textf \"this component has been alive for %d frames\" frames ;; The text I chose for that component was very intentional. I wrote \"this component has been alive for {n} frames\" instead of \"the application has been running for {n} frames\". This is because Edge functions only run if their computation is active. Let's start with a demo, and then discuss what \"active\" means. ocaml let frame_toggler = let%sub showing, set_showing = Bonsai.state false in let%sub output = match%sub showing with | true -> frame_counter | false -> Bonsai.const Vdom.Node.none in let%arr showing = showing and set_showing = set_showing and output = output in let toggle_showing = set_showing (not showing) in let button_text = if showing then \"disable counter\" else \"enable counter\" in let toggle_button = Vdom.Node.button ~attrs:[ Vdom.Attr.on_click (fun _ -> toggle_showing) ] [ Vdom.Node.text button_text ] in Vdom.Node.div [ toggle_button; output ] ;; If you disable the component (wait a few seconds), you'll notice that the counter picks up where it left off rather than continuing in the background.As mentioned earlier, after_display only runs when the computation is \"active\", and as this example demonstrates, being inside of a match%sub is one way to change the activity status of a computation.In fact, aside from match%sub , there's only one other combinator that influences the active status: Bonsai.assoc . Technically, if%sub and Bonsai.enum_ also have this property, but in reality, if%sub and match%sub are implemented in terms of enum_ , so they're all counted together. Bonsai.assoc is used to build a dynamic number of instances of a computation.Just like how ocaml let%sub a = my_component in let%sub b = my_component in will create two distinct instances of my_component , each with their own state, Bonsai.assoc can instantiate a dynamic number of computations, one instantiation per key-value pair from an incoming _ Map.t Value.t .I have a small library, https://ocaml.org/p/bonsai/v0.15.0/doc/Bonsai_web_ui_extendy/index.html Bonsai_web_ui_extendy, which uses assoc to implement a component for easily creating and deleting instances of another component.We'll reuse the frame_counter component built in the first example, and combine it with extendy to get multiple frame_counter s.Let's see it in use: <!-- $MDX file=../../examples/bonsai_guide_code/edge_examples.ml,part=extendy-use --> {=html} ocaml let wrap_remove frame_counter remove = let x_button = Vdom.Node.button ~attrs:[ Vdom.Attr.on_click (fun _ -> remove) ] [ Vdom.Node.text \"x\" ] in Vdom.Node.div [ x_button; frame_counter ] ;; let many_frame_watches = let%sub { contents; append; _ } = extendy frame_counter ~wrap_remove in let%arr contents = contents and append = append in let append_button = Vdom.Node.button ~attrs:[ Vdom.Attr.on_click (fun _ -> append) ] [ Vdom.Node.text \"add\" ] in Vdom.Node.div (append_button :: Map.data contents) ;; By clicking on the \"add\" button, we create multiple frame-counters, each with their own state, each which began counting at the moment of their creation. It might not be obvious, but clicking on the x button not only removes the component from the view, but from the entire Bonsai computation graph, so the on_display effect is also stopped entirely."],["guide@@09-edge-triggering@@on_activate-on_deactivate","Guide","Edge Triggering","on_activate / on_deactivate","The other two optional parameters to Bonsai.Edge.lifecycle are on_activate and on_deactivate , both of which share the same type as after_display : unit Effect.t Value.t . These effects are run whenever the lifecycle computation becomes active or inactive. By incorporating a lifecycle computation into a component of yours, the on_activate / on_deactivate callbacks are effectively measuring the activation/deactivation of the containing component. Let's modify the lifecycle component to use these new functions. First, though, we'll want to do something when the activation/deactivation occurs. For that, I built a tiny logging component which will let me append a list of strings sent by the frame_counter component.Ok, on to the extension of frame_counter : ocaml let frame_counter (log : (string -> unit Ui_effect.t) Value.t) = let%sub frames, set_frames = Bonsai.state 0 in let%sub () = Bonsai.Edge.lifecycle ~on_activate: (let%map log = log in log \"🚀\") ~on_deactivate: (let%map log = log in log \"🔥\") ~after_display: (let%map frames = frames and set_frames = set_frames in set_frames (frames + 1)) () in let%arr frames = frames in Vdom.Node.textf \"this component has been alive for %d frames\" frames ;; If you don't like the look of ocaml let%map log = log in log \"🔥\" you could also write it as ocaml log >>| Fn.( |> ) \"🔥\" <br/> {=html} Please don't though # on_change With the `lifecycle` function as a primitive, we can implement other useful edge-triggering functions. One of these is also included in the `Bonsai.Edge` module: `on_change'`. `on_change'` monitors a `'a Value.t`, and when that value changes, it calls a user-provided function, giving that function both the previous and current value. This user-provided function returns an `Effect.t`, which will be scheduled whenever the value changes. ``````attention-note You currently have all the tools to implement `on_change'` yourself, and you can find the implementation [here](https://github.com/janestreet/bonsai/blob/master/src/proc.ml#L832). Combining the counter-component from ./03-state.md Chapter 3 and the logging component that I used above, we can write a component which contains both a counter and a log, where the log is updated when the value changes. ocaml let logging_counter = let%sub log_view, log = logger in let%sub counter_view, counter = counter in let%sub () = let callback = let%map log = log in fun prev cur -> match prev with | None -> Ui_effect.Ignore | Some prev -> log (if prev < cur then \"🚀\" else \"🔥\") in Bonsai.Edge.on_change' ~sexp_of_model:[%sexp_of: Int.t] ~equal:[%equal: Int.t] counter ~callback in let%arr log_view = log_view and counter_view = counter_view in Vdom.Node.div [ counter_view; log_view ] ;; Implications for intelligibility and testing Declarative programs are easy to reason about and test. Extensive use of the Edge module will make your program less and less declarative.Every time that you have the opportunity, you should opt for using anything other than an Edge.* function.However, sometimes it's necessary, and we have testing helpers to make your life a bit easier when you do use edge triggering. Because after_display runs its effect, well, after the display has occurred, how would this interact with Bonsai testing functions, like Handle.show ?To demonstrate, we'll build an awful Bonsai component: a linear chain of on_changes : ocaml let chain_computation = let%sub a = Bonsai.const \"x\" in let%sub b, set_b = Bonsai.state \" \" ~sexp_of_model:[%sexp_of: String.t] ~equal:[%equal: String.t] in let%sub c, set_c = Bonsai.state \" \" ~sexp_of_model:[%sexp_of: String.t] ~equal:[%equal: String.t] in let%sub d, set_d = Bonsai.state \" \" ~sexp_of_model:[%sexp_of: String.t] ~equal:[%equal: String.t] in let%sub () = Bonsai.Edge.on_change ~sexp_of_model:[%sexp_of: String.t] ~equal:[%equal: String.t] a ~callback:set_b in let%sub () = Bonsai.Edge.on_change ~sexp_of_model:[%sexp_of: String.t] ~equal:[%equal: String.t] b ~callback:set_c in let%sub () = Bonsai.Edge.on_change ~sexp_of_model:[%sexp_of: String.t] ~equal:[%equal: String.t] c ~callback:set_d in return (Value.map4 a b c d ~f:(sprintf \"a:%s b:%s c:%s d:%s\")) ;; Because on_change triggers at the end of each frame, it should take 4 frames to settle. And indeed, in a unit test, that's exactly what we'll see: ocaml let%expect_test \"chained on_change\" = let handle = Handle.create (Result_spec.string (module String)) chain_computation in Handle.show handle; [%expect {| a:x b: c: d: |}]; Handle.show handle; [%expect {| a:x b:x c: d: |}]; Handle.show handle; [%expect {| a:x b:x c:x d: |}]; Handle.show handle; [%expect {| a:x b:x c:x d:x |}]; Handle.show handle; [%expect {| a:x b:x c:x d:x |}] ;; But Bonsai_web_test.Handle has a function that makes this a bit nicer: recompute_view_until_stable , so we can rewrite the test in a way that skips all the intermediate frames: ocaml let%expect_test \"chained on_change with recompute_view_until_stable\" = let handle = Handle.create (Result_spec.string (module String)) chain_computation in Handle.recompute_view_until_stable handle; Handle.show handle; [%expect {| a:x b:x c:x d:x |}] ;; recompute_view_until_stable is handy, but it's hiding intermediate states. If those intermediate states allow for logical bugs in your application, then you might miss them. As mentioned above: avoid Edge if you can; it's a sharp tool."],["guide@@10-url-routing@@handwritten-parse-unparse","Guide","URL Routing","Handwritten Parse / Unparse","For any web application that supports navigation between different pages, URLs can be an easy way to dramatically improve the user experience: they automatically give your app some very useful featuresUsers can save and share links to specific navigational states within the app The browser's forward and back buttons allow quick historical navigation Reading and editing URLs can be used (as a last resort maybe) for precise navigation It might not be obvious at first, but URL integration is bidirectional:when the URL changes, the application responds by updating its navigation when the user navigates in the app, the URL should be updated to match In Bonsai, the 'a Url_var.t type is used to manage this synchronization; when given a parsing function (that parses a URL into values of your domain-specific 'a type) and an \"unparsing\" function (which turns 'a back into a URL), the url-var can be treated like a ./02-dynamism.md Var.t and it'll handle all the browser-specific url management for you!In this guide, we'll start by building a url-var by implementing parse and unparse by hand, but the rest of this chapter will focus on the API built for the typed-fields ppx, which will simultaneously generate the parser and unparser functions for you (and ensure that the printer and parser round-trip)!Imagine you have a site with the following URLs: /search?q=capybara /settings URL Var's previous API allowed you to parse/unparse this URL by you manually implementing its parse and unparse functions: ocaml module My_google_clone = struct type t = | Homepage | Search of string [@@deriving sexp, equal] let parse_exn ({ path; query; _ } : Url_var.Components.t) : t = let path = String.split path ~on:'/' in match path with | [ \"home\" ] -> Homepage | [ \"search\" ] -> (match Map.find (query : _ String.Map.t) \"q\" with | Some [ query ] -> Search query | None | Some [] -> failwith \"search missing query param\" | Some (_ :: _ :: _) -> failwith \"search with too many query params\") | _ -> failwith \"unknown path\" ;; let unparse (t : t) : Url_var.Components.t = match t with | Homepage -> Url_var.Components.create ~path:\"home\" () | Search query -> Url_var.Components.create ~path:\"search\" ~query:(String.Map.singleton \"q\" [ query ]) () ;; end You would have needed to write your own tests in order verify that your parser/unparser successfully round-trip ( parse_exn(unparse(x)) gives you back the original x )."],["guide@@10-url-routing@@typed-field-parse-unparse","Guide","URL Routing","Typed field Parse / Unparse","With URL Var's typed field API, you can define a module that is able to parse a URL into My_google_clone.t and unparse My_google_clone.t into a URL: ocaml module My_google_clone = struct type t = | Homepage | Search of string [@@deriving typed_variants, sexp, equal] let parser_for_variant : type a. a Typed_variant.t -> a Parser.t = function | Homepage -> Parser.unit | Search -> Parser.from_query_required ~key:\"q\" Value_parser.string ;; end let parser = Parser.Variant.make (module My_google_clone) let versioned_parser = Versioned_parser.first_parser parser let%expect_test _ = Parser.check_ok_and_print_urls_or_errors parser; [%expect {| URL parser looks good! ┌────────────────────┐ │ All urls │ ├────────────────────┤ │ /homepage │ │ /search?q=<string> │ └────────────────────┘ |}] ;; After creating a My_google_clone.t Url_var.t like this: let url_var = Url_var.Typed.make (module My_google_clone) versioned_parser ~fallback:(fun _exn _components -> My_google_clone.Whoops) ;; You can then get an automatically-updating My_google_clone.t Value.t with Url_var.value which updates any time that the url changes and can be threaded into the Bonsai computation like any other Value.t .On the other side, Url_var.set_effect can be called to to change the content of the url-var, and in doing so, will update the URL to reflect it.The rest of the operations for Url_var.t are intended to be used outside of a bonsai app: type 'a t (* for use in bonsai computation *) val value : 'a t -> 'a Value.t val set_effect : 'a t -> 'a -> unit Effect.t (* for use outside of bonsai computation *) val update : 'a t -> f:('a -> 'a) -> unit val set : 'a t -> 'a -> unit val get : 'a t -> 'a The actual call to Url_var.Typed.make must only run in a web-browser. This means that if you've factored your app out into a standard lib/ , test/ bin/ structure, then the Url_var.Typed.make function should be located in bin/ . If you stick it in the lib/ section, then tests in test/ may fail because the url-var can't deal with being in an expect-test environment. If you are using cohttp_static_handler's Single_page_handler to serve your page, it will redirect unknown urls on its own which prevents url_var from doing any parsing/error handling. You can get around this by setting the on_unknown_url parameter to `Index Single_page_handler.create_handler ~title:<title> ~assets:<assets> ~on_unknown_url:`Index What is a path and what is a query? URLs have lots of different https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_URL parts:However, URL Var only focuses on two of them, the path and the query.Given example.com/path/to/my/file?key1=value1&key2=value2&key3=value3 has the following parts: - Path path/to/my/file - Query ?key1=value1&key2=value2&key3=value3 In the eyes of URL Var, a path is a list of strings separated by / , and a query is a key-value pair list separated by & . The functions in the Typed API make heavy use of this terminology.The path and query together are represented like this: module Components = struct type t = { path : string list ; query : string list String.Map.t } end Something that's weird about the above representation is that the query is a string-to-string-list pairing instead of a string-to-string pairing. The reason for this is weird. What should \"?a=1&a=2&a=3\" parse to? Some browsers parse this to {a : [1, 2, 3]} , others drop all of the duplicate instances except one, others even https://stackoverflow.com/questions/32572264/what-might-be-shufflling-my-query-string-parameters-constructed-in-javascript shuffle the keys as an anti-tracking measure. URL Var disallows repeated keys. When you use from_query_many the URL shape it expects is \"?a=1,2,3\" instead of \"?a=1&a=2&a=3\" . When should you put something in the path vs. in the query? There's no right and wrong answer, ultimately it's a matter of taste: a URL like website.com/profile/capybara_lover123 feels better than website.com?profile=capybara_lover123 and likewise posts?after=dec-2 is preferable to posts/after/dec-2 .A good rule of thumb is that paths should be used for things that are \"resource-like\", and query-parameters be used for optional or configurable parameters to that resource. Records If you want to parse/unparse your URL or a part of your URL as a record you can use the Parser.Record module which needs you to derive typed_fields on your record type. ocaml module My_google_clone = struct type t = { query : string ; language : string } [@@deriving typed_fields, sexp, equal] let parser_for_field : type a. a Typed_field.t -> a Parser.t = function | Query -> Parser.from_query_required ~key:\"q\" Value_parser.string | Language -> Parser.from_query_required Value_parser.string ;; module Path_order = Parser.Record.Path_order (Typed_field) let path_order = Path_order.T [] end let parser = Parser.Record.make (module My_google_clone) let%expect_test _ = Parser.check_ok_and_print_urls_or_errors parser; [%expect {| URL parser looks good! ┌────────────────────────────────┐ │ All urls │ ├────────────────────────────────┤ │ /?language=<string>&q=<string> │ └────────────────────────────────┘ |}] ;; The key of Query is \"q\" since it's explicitly given through the key optional parameter. The key of Language is \"language\" which was inferred with the help of typed_fields since no key was given. path_order is not really doing anything right now, but will be useful shortly. The : type a. a Typed_field.t -> a Parser.t type annotation might be confusing if it's the first time you see it, but the good and bad thing is that it's always the same annotation. The reason that this annotation is needed is because 'a Typed_field.t is a GADT, which results in each of its constructors having different types which can result in weird type errors without the explicit annotation. There are cool internal talks and resources that go over this topic in more detail, but for now, it's totally fine to just always type the same type annotation type a. a Typed_field.t -> a Parser.t . It might be good to have [language] have its own type. We can use Parser.project or Value_parser.project to change their types. ocaml module My_google_clone = struct module Language : sig type t [@@deriving sexp, equal] val to_string : t -> string val of_string : string -> t end = struct include String end type t = { query : string ; language : Language.t } [@@deriving typed_fields, sexp, equal] let parser_for_field : type a. a Typed_field.t -> a Parser.t = function | Query -> Parser.from_query_required ~key:\"q\" Value_parser.string | Language -> Parser.from_query_required (Value_parser.project Value_parser.string ~parse_exn:Language.of_string ~unparse:Language.to_string) ;; module Path_order = Parser.Record.Path_order (Typed_field) let path_order = Path_order.T [] end let parser = Parser.Record.make (module My_google_clone) let%expect_test _ = Parser.check_ok_and_print_urls_or_errors parser; [%expect {| URL parser looks good! ┌─────────────────────────────────────────┐ │ All urls │ ├─────────────────────────────────────────┤ │ /?language=<project<string>>&q=<string> │ └─────────────────────────────────────────┘ |}] ;; We could've also used Value_parser.stringable (module Language) as a shorthand for projecting stringable types. On a similar note, Value_parser also provides other primitives like sexpable and binable_via_base64 , int , float , and others. Right now, we are taking both fields the query, but you might want to design your URL such that users see google.com/en/?q=capybara instead of google.com/?language=en&q=capybara . Instead of from_query_required , we can use from_path . ocaml module My_google_clone = struct module Language : sig type t [@@deriving sexp, equal] val to_string : t -> string val of_string : string -> t end = struct include String end type t = { query : string ; language : Language.t } [@@deriving typed_fields, sexp, equal] let parser_for_field : type a. a Typed_field.t -> a Parser.t = function | Query -> Parser.from_query_required ~key:\"q\" Value_parser.string | Language -> Parser.from_path (Value_parser.project Value_parser.string ~parse_exn:Language.of_string ~unparse:Language.to_string) ;; module Path_order = Parser.Record.Path_order (Typed_field) let path_order = Path_order.T [] end let parser = Parser.Record.make (module My_google_clone) let%expect_test _ = Parser.check_ok_and_print_urls_or_errors parser; [%expect {| Error with parser. ┌────────────────────────┬───────────────────────────────────────────────────────────────────────────────────────┐ │ Check name │ Error message │ ├────────────────────────┼───────────────────────────────────────────────────────────────────────────────────────┤ │ Sane path orders check │ (\"Each path parser must be present in path order. The following fields were missing:\" │ │ │ (missing_fields (Language))) │ └────────────────────────┴───────────────────────────────────────────────────────────────────────────────────────┘ |}] ;; We get an error! The reason for this is that, unlike query fields where keys can be parsed and unparsed in any order since it's a string list String.Map.t under the hood, the path is just a string list where the order in which you parse things matters. A URL like google.com/search/en is different from google.com/en/search . If you take multiple fields from the path, then you need to specify the order in which they should be parsed and unparsed in. check_ok_and_print_urls_or_errors will let you know about any issues statically. Here the problem can be fixed by adding Language to path_order . ocaml module My_google_clone = struct module Language : sig type t [@@deriving sexp, equal] val to_string : t -> string val of_string : string -> t end = struct include String end type t = { query : string ; language : Language.t } [@@deriving typed_fields, sexp, equal] let parser_for_field : type a. a Typed_field.t -> a Parser.t = function | Query -> Parser.from_query_required ~key:\"q\" Value_parser.string | Language -> Parser.from_path (Value_parser.project Value_parser.string ~parse_exn:Language.of_string ~unparse:Language.to_string) ;; module Path_order = Parser.Record.Path_order (Typed_field) let path_order = Path_order.T [ Language ] end let parser = Parser.Record.make (module My_google_clone) let%expect_test _ = Parser.check_ok_and_print_urls_or_errors parser; [%expect {| URL parser looks good! ┌───────────────────────────────┐ │ All urls │ ├───────────────────────────────┤ │ /<project<string>>?q=<string> │ └───────────────────────────────┘ |}] ;; Finally, although it's not ergonomic in this example, it's worth mentioning what happens when you nest records. ocaml module Nested = struct type t = { foo : string ; bar : int } [@@deriving typed_fields, sexp, equal] let parser_for_field : type a. a Typed_field.t -> a Parser.t = function | Foo -> Parser.from_query_required Value_parser.string | Bar -> Parser.from_query_required Value_parser.int ;; module Path_order = Parser.Record.Path_order (Typed_field) let path_order = Path_order.T [] end module Parent = struct type t = { a : Nested.t ; b : Nested.t } [@@deriving typed_fields, equal, sexp] let parser_for_field : type a. a Typed_field.t -> a Parser.t = function | A -> Parser.Record.make (module Nested) | B -> Parser.Record.make (module Nested) ;; module Path_order = Parser.Record.Path_order (Typed_field) let path_order = Path_order.T [] end let parser = Parser.Record.make (module Parent) let%expect_test _ = Parser.check_ok_and_print_urls_or_errors parser; [%expect {| URL parser looks good! ┌─────────────────────────────────────────────────────────┐ │ All urls │ ├─────────────────────────────────────────────────────────┤ │ /?a.bar=<int>&a.foo=<string>&b.bar=<int>&b.foo=<string> │ └─────────────────────────────────────────────────────────┘ |}] ;; Records nested inside of other records are namespaced on top of each other, but the namespace can be changed/be overridden with the optional parameter ~namespace on Parser.Record.make . Variants If you want to parse/unparse your URL or a part of your URL as a variant you can use the Parser.Variant module which needs you to derive typed_variants on your variant type. ocaml module My_google_clone = struct type t = | Homepage | Search | Maps [@@deriving typed_variants, sexp, equal] let parser_for_variant : type a. a Typed_variant.t -> a Parser.t = function | Homepage -> Parser.unit | Search -> Parser.unit | Maps -> Parser.unit ;; end let parser = Parser.Variant.make (module My_google_clone) let%expect_test _ = Parser.check_ok_and_print_urls_or_errors parser; [%expect {| URL parser looks good! ┌───────────┐ │ All urls │ ├───────────┤ │ /homepage │ │ /maps │ │ /search │ └───────────┘ |}] ;; Parser.unit is a no-op parser for when you don't need to parse anything. Its type is unit Parser.t and is useful when dealing with variant constructors that don't have a payload. It would be nice if we could express a homepage as google.com/ instead of google.com/homepage . ocaml module My_google_clone = struct type t = | Homepage | Search | Maps [@@deriving typed_variants, sexp, equal] let parser_for_variant : type a. a Typed_variant.t -> a Parser.t = function | Homepage -> Parser.end_of_path Parser.unit | Search -> Parser.unit | Maps -> Parser.unit ;; end let parser = Parser.Variant.make (module My_google_clone) let%expect_test _ = Parser.check_ok_and_print_urls_or_errors parser; [%expect {| URL parser looks good! ┌──────────┐ │ All urls │ ├──────────┤ │ / │ │ /maps │ │ /search │ └──────────┘ |}] ;; The path identifiers for Maps and Search were inferred with the help of typed_variants , and the homepage identifier was overridden with end_of_path . When something gets inferred vs when it's overridden can be tricky to reason about, but the way it works is that the \"pattern\" to match will be inferred unless the following combinators are used: - with_remaining_path pattern expects the remaining path to be equal to pattern . - with_prefix pattern expects the remaining path to have pattern as its prefix. - end_of_path expect the remaining path to be empty. It would be nice if we had payload on the URL like google.com/search?query=capybara or google.com/maps?location=New_York . This can be accomplished with the same combinators that the previous Parser.Record example used. ocaml module My_google_clone = struct type t = | Homepage | Search of string | Maps of string [@@deriving typed_variants, sexp, equal] let parser_for_variant : type a. a Typed_variant.t -> a Parser.t = function | Homepage -> Parser.end_of_path Parser.unit | Search -> Parser.from_query_required ~key:\"query\" Value_parser.string | Maps -> Parser.from_query_required ~key:\"location\" Value_parser.string ;; end let parser = Parser.Variant.make (module My_google_clone) let%expect_test _ = Parser.check_ok_and_print_urls_or_errors parser; [%expect {| URL parser looks good! ┌─────────────────────────┐ │ All urls │ ├─────────────────────────┤ │ / │ │ /maps?location=<string> │ │ /search?query=<string> │ └─────────────────────────┘ |}] ;; Static checks on your url parsing/unparsing Parser.check_ok_and_print_urls_or_errors will check for any ambiguity/weirdness in your parser. You'll also be able to see if the urls your site supports changes unexpectedly. The library tends to infer things off of the names of your types. For instance, paths are sometimes inferred from constructor names, but can be overridden with end_of_path , with_prefix or with_remaining_path . The rules for how this works are specified in the MLI, but it's a lot nicer to explicitly see the shapes of your url in an expect test. ocaml module Ambiguous_url = struct type t = | Foo | Bar [@@deriving typed_variants, sexp, equal] let parser_for_variant : type a. a Typed_variant.t -> a Parser.t = function | Foo -> Parser.with_prefix [ \"x\" ] Parser.unit | Bar -> Parser.with_prefix [ \"x\" ] Parser.unit ;; end let parser = Parser.Variant.make (module Ambiguous_url) let%expect_test _ = Parser.check_ok_and_print_urls_or_errors parser; [%expect {| Error with parser. ┌─────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────────────────────────────────────────┐ │ Check name │ Error message │ ├─────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤ │ Ambiguous choices for picking variant constructor check │ (\"Duplicate patterns found!\" │ │ │ (duplicate_patterns (((pattern ((Match x))) (needed_match Prefix))))) │ │ Duplicate urls check │ (\"Ambiguous, duplicate urls expressed in parser! This was probably caused due to conflic │ │ │ ting renames with [with_prefix] or [with_remaining_path].\" │ │ │ (duplicate_urls (/x))) │ └─────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘ |}] ;; No more broken links in documents As your site changes, it's likely that your parser will also change, which introduces the possibility that old urls no longer parse! Broken urls in your users' documents is not fun, but you can guard against this by using Versioned_parser to \"stabilize\" them. ocaml module V1 = struct type t = Foo of string [@@deriving typed_variants, sexp, equal] let parser_for_variant : type a. a Typed_variant.t -> a Parser.t = function | Foo -> Parser.from_path Value_parser.string ;; end let v1_parser = Versioned_parser.first_parser (Parser.Variant.make (module V1)) module V2 = struct type t = New_foo of string [@@deriving typed_variants, sexp, equal] let parser_for_variant : type a. a Typed_variant.t -> a Parser.t = function | New_foo -> Parser.from_path Value_parser.string ;; end let v2_parser = Versioned_parser.new_parser (Parser.Variant.make (module V2)) ~previous:v1_parser ~f:(function | Foo s -> New_foo s) ;; let%expect_test _ = Versioned_parser.check_ok_and_print_urls_or_errors v2_parser; [%expect {| URL parser looks good! ┌───────────────────┐ │ All urls │ ├───────────────────┤ │ /new_foo/<string> │ └───────────────────┘ | falls back to | v URL parser looks good! ┌───────────────┐ │ All urls │ ├───────────────┤ │ /foo/<string> │ └───────────────┘ |}] ;; If you're migrating your site from the non-typed URL var into the Typed version of the API, then you cannot use Versioned_parser.first_parser since you won't already have a Typed.Parser . But no worries! You can use Versioned_parsed.of_non_typed_parser instead of Versioned_parser.first_parser More resources The MLI is quite long, so here are some pointers to save you time! I want my URL type to be a record! -> You should look for Typed.Record.make in the MLI/demo page. I want my URL to take things from the path (e.g. \"/profile/capybara_lover123\" or \"/profile/chinchilla_was_taken\" or \"profile/<string>\") -> You can use Parser.from_path and Parser.from_remaining_path for the \"variable parts\" of the path and with_prefix and with_remaining_path for the \"constant\" parts. Examples are in demo page + better explanation in MLI. I want my URL type to be made up of something other than the provided primitives! -> Value_parser.project or Parser.project should do the trick! What are all the provided primitives?? -> These primitives are located and documented in Value_parser . What order do the parsers/unparsers run? -> Preorder-like order. Records' fields are weirder since the order you parse the record's fields might lead to different results, you can specify the order through path_order . I want my [Value_parser] to recover from failure. -> You can use Value_parser.fallback to provide a default value to use when the parser fails."],["guide@@11-rpcs@@example-1-doubling-a-number","Guide","RPCs","Example 1: Doubling a number","Historically, the recommended structure of a web app that sends RPCs was something like this:Use persistent_connection to establish a connection the server and client can use to communicate. Thread that connection as an argument through the whole codebase so that RPCs can be dispatched directly from anywhere. By threading the connection as an argument instead of always referencing a global connection value, we can pass in a different connection for testing purposes; otherwise test code would have to spin up a server process, which would add an unfortunate amount of non-determinism and awkwardness to each test. The Rpc_effect module adds a couple refinements to make this approach more ergonomic:Instead of explicitly threading the connection through the whole app, Rpc_effect uses a dynamic-scoping construct built into Bonsai that allows code to pull the connection \"out of thin air\". This reduces parameter-passing noise, at the cost of some extra noise anytime something dispatches an RPC. The module will create connections for you, which reduces the typical app setup boilerplate. Bonsai_web_test.Handle.create optionally accepts a set of RPC implementations, thus eliminating the boilerplate of setting up a connection that works in tests. In this example, we will build the UI shown below. It has a button that sends the current number as an RPC query and sets the number to whatever number is in the response that comes back.The first step is to define an RPC that is shared between the server and client code. ocaml let double_rpc = Rpc.Rpc.create ~name:\"double\" ~version:0 ~bin_query:[%bin_type_class: int] ~bin_response:[%bin_type_class: int] ;; Next, we provide the server's implementation of the RPC. ocaml let double_implementation = Rpc.Rpc.implement' double_rpc (fun _connection_state query -> Int.max 1 (query * 2)) ;; On the client side, we start by picking a server to send our RPCs to. Most users will pick Self , which causes RPCs to be sent to the same server hosting the web page itself. ocaml let where_to_connect : Rpc_effect.Where_to_connect.t = Self Finally, we can build the client side of the app. ocaml let app = let%sub dispatch_double_rpc = Rpc_effect.Rpc.dispatcher double_rpc ~where_to_connect in let%sub number, set_number = Bonsai.state ~equal:[%equal: int] 1 in let%arr dispatch_double_rpc = dispatch_double_rpc and number = number and set_number = set_number in Vdom.Node.div [ Vdom.Node.div [ Vdom.Node.text [%string \"The number is: %{number#Int}\"] ] ; Vdom.Node.button ~attrs: [ Vdom.Attr.on_click (fun _ -> match%bind.Effect dispatch_double_rpc number with | Ok doubled_number -> set_number doubled_number | Error error -> Effect.of_sync_fun eprint_s [%sexp (error : Error.t)]) ] [ Vdom.Node.text \"Double the number\" ] ] ;; The one line worth highlighting is the one that makes the RPC-dispatching effect. ocaml skip let%sub dispatch_double_rpc = Rpc_effect.Rpc.dispatcher Protocol.double ~where_to_connect in This does not by itself dispatch an RPC; rather, it merely produces a 'query -> 'response Effect.t function that will do the dispatching."],["guide@@11-rpcs@@polling-state-rpc","Guide","RPCs","Polling State RPC","Bonsai apps often use a library called polling_state_rpc whenever they want to keep up to date with a source of data. The library provides a similar abstraction to the Pipe_rpc or State_rpc modules that come built into async_rpc_kernel , but with tradeoffs that are more suitable for web clients.Both Pipe_rpc and State_rpc operate by pushing streams of updates through the connection; the client can then consume this stream of events as appropriate. This approach works great if the client is able to keep up with the stream of events, as is often the case with native programs. However, web clients are interesting in that they frequently get backgrounded; if the user switches away from a browser tab, the Bonsai rendering loop, which relies on the browser's requestAnimationFrame function, slows down to a crawl. If the app uses State_rpc , then when the tab eventually comes back to the foreground, it might have a large queue of events, which will cause it to freeze while it catches up.The polling_state_rpc library solves this problem by having the client say when it is ready for more data by explicitly requesting updates from the server. This allows the server to give the client a condensed view of everything that happened since the last time it requested data."],["guide@@11-rpcs@@example-2-display-the-current-time","Guide","RPCs","Example 2: Display the current time","This next example will build a UI that monitors the current time reported by the server, in order to provide a concrete example of using the polling_state_rpc library.Ten times a second, the client sends the timezone text as a poll query to the server, to which it responds with the current time formatted in the specified zone. Ordinarily the form would be more structured so that the user can't accidentally send the server an invalid form; however, this UI does nothing of the sort, in order to illustrate how error handling might work.As in the previous example, we will begin by setting up the RPC definition. The point of interest in this case is that we must provide a module for the response type that satisfies the Diffable.S module type (from the diffable library). ocaml module Current_time = struct include String include Diffable.Atomic.Make (String) end let current_time_rpc = Polling_state_rpc.create ~name:\"current_time\" ~version:0 ~query_equal:[%equal: string] ~bin_query:[%bin_type_class: string] (module Current_time) ;; Next we provide a server implementation. A call to Rpc.Implementation.lift is common because the implementation you get from Polling_state_rpc.implement requires a 'a * Rpc.Connection.t connection state. ocaml let current_time_implementation = Polling_state_rpc.implement ~on_client_and_server_out_of_sync:print_s current_time_rpc (fun _connection_state zone -> Deferred.return (Time_ns.to_string_trimmed ~zone:(Timezone.of_string zone) (Time_ns.now ()))) |> Rpc.Implementation.lift ~f:(fun connection_state -> connection_state, connection_state) ;; Finally, we can write the UI code. There are a couple important ways in which this example is different from the previous one:Rather than explicitly dispatching the RPC, we merely instantiate the poller computation and allow it to send requests as necessary. It sends requests whenever the query (the timezone) changes, and also at fixed intervals (every tenth of a second). Rather than having to dispatch the RPC to get the response or an error, we get a couple constantly available values: last_ok_response and last_error . Each of those values comes packaged with the query it was a response to, since it might lag slightly behind the most up-to-date query. The code omits the implementation of zone_form , since that is not our focus in this chapter. ocaml let app = let%sub zone, zone_view = zone_form in let%sub { last_ok_response; last_error; inflight_query = _; refresh = _ } = Rpc_effect.Polling_state_rpc.poll current_time_rpc ~equal_query:[%equal: string] ~equal_response:[%equal: Current_time.t] ~where_to_connect ~every:(Time_ns.Span.of_sec 0.1) zone in let%arr last_ok_response = last_ok_response and last_error = last_error and zone_view = zone_view in let text = match last_ok_response with | Some (zone, current_time) -> [%string \"The current time in the zone '%{zone}' is %{current_time}\"] | None -> \"Loading...\" in let error_view = match last_error with | Some (zone, error) -> Vdom.Node.div ~attrs:[ Css.error_text ] [ Vdom.Node.text [%string \"Got error when requesting time in zone '%{zone}'\"] ; Vdom.Node.pre [ Vdom.Node.text (Error.to_string_hum error) ] ] | None -> Vdom.Node.none in Vdom.Node.div [ zone_view; Vdom.Node.div [ Vdom.Node.text text ]; error_view ] ;;"],["guide@@11-rpcs@@example-3-testing-a-component-that-sends-rpcs","Guide","RPCs","Example 3: Testing a component that sends RPCs","Let us return to the \"number doubler\" that we built in the first example. In this section we will build some tests for that component. Using knowledge from the testing chapter of the guide, our first attempt might look like the code below. ocaml let%expect_test \"Clicking the button should double the number\" = let handle = Handle.create (Result_spec.vdom Fn.id) app in Handle.show handle; [%expect {| <div> <div> The number is: 1 </div> <button onclick> Double the number </button> </div> |}]; Handle.click_on handle ~get_vdom:Fn.id ~selector:\"button\"; Handle.show handle; [%expect {| <div> <div> The number is: 1 </div> <button onclick> Double the number </button> </div> |}] ;; Sadly, it isn't this simple. The first reason is that since RPCs are dispatched asynchronously, the test must itself be async. Native tests would accomplish this by adding open Async at the top of the test file, but since we're running in javascript, we have to use a different library. ocaml open Async_kernel open Async_js_test Here's what our attempt looks like now. In addition to the above module imports, we also use Async_kernel_scheduler.yield_until_no_jobs_remain to force any pending side-effects to happen before the test quits. If we don't include that call, the output still gets printed, but after the return () , which means the test doesn't typecheck. ocaml let%expect_test \"Clicking the button should double the number\" = let handle = Handle.create (Result_spec.vdom Fn.id) app in Handle.show handle; [%expect {| <div> <div> The number is: 1 </div> <button onclick> Double the number </button> </div> |}]; Handle.click_on handle ~get_vdom:Fn.id ~selector:\"button\"; Handle.show handle; [%expect {| <div> <div> The number is: 1 </div> <button onclick> Double the number </button> </div> |}]; let%bind () = Async_kernel_scheduler.yield_until_no_jobs_remain () in [%expect {| \"RPC not handled because no connector has been provided.\" |}]; return () ;; We're close, but we need to provide an implementation for the RPC that the button tried to invoke. Thankfully, double_implementation from earlier is still lying around, so we can simply use that. (In some apps you might want to include a mock implementation that differs from the real one.) We should also yield to the scheduler before showing the output, so that we can see the effect of the RPC completing. ocaml let%expect_test \"Clicking the button should double the number\" = let handle = Handle.create ~rpc_implementations:[ double_implementation ] (Result_spec.vdom Fn.id) app in Handle.show handle; [%expect {| <div> <div> The number is: 1 </div> <button onclick> Double the number </button> </div> |}]; Handle.click_on handle ~get_vdom:Fn.id ~selector:\"button\"; let%bind () = Async_kernel_scheduler.yield_until_no_jobs_remain () in Handle.show handle; [%expect {| <div> <div> The number is: 2 </div> <button onclick> Double the number </button> </div> |}]; return () ;; Hurrah! This test successfully demonstrates the effect of clicking the button. There are a lot more tricky things about asynchronous testing that this chapter could cover, but we've opted to stop here. Admittedly, the tools for testing with RPCs are still in their infancy, so if you have ideas about how to make writing these tests easier, let us know."]]
/*
 * Copyright 2019 TWO SIGMA OPEN SOURCE, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

znaiSearchIdx = lunr(function () {
    this.ref('id')
    this.field('section')
    this.field('pageTitle')
    this.field('pageSection')
    this.field('text')

    this.metadataWhitelist = ['position']

    znaiSearchData.forEach(function (e) {
        this.add({
            id: e[0],
            section: e[1],
            pageTitle: e[2],
            pageSection: e[3],
            text: e[4],
        })
    }, this)
})
